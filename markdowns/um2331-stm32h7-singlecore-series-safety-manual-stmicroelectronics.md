# STM32H7 single-core series safety manual

# Introduction

T usle STM32H7 single-core series microcontroller devices, available on www.st.com.

avoid going into unnecessary details.

The document is written in compliance with IEC 61508.

package.

# 1 About this document

# 1.1 Purpose and scope

This document describes how to use Arm® Cortex®-M7 -based STM32H7 single-core series microcontroller unit )eviurheereviinheont afey-elat yste user's resonsibilities orinstallation andoperation, inorder to reach the desiesafety integrity vel.

It isu i alal.   
For terms used, refer to the glossary at the end of the document.

# Note:

Arm is a registered trademark of Arm Limited (or its subsidiaries) in the US and/or elsewhere.

# 1.2 Normative references

Thdocentriepliance withhe EC0teatial orm nctioal feyell, electronic and programmable electronic safety-related systems, version IEC 61508-1-7 © IEC:2010. The compliance to other functional safety standards is considered in reference document [3].

The following table maps the document content with respect to the IEC 61508-2 Annex D requirements.

Table 1. Document sections versus IEC 61508-2 Annex D safety requirements   

<table><tr><td rowspan=1 colspan=1>Safetyrequirement</td><td rowspan=1 colspan=1>Section number</td></tr><tr><td rowspan=1 colspan=1>D2.1 a</td><td rowspan=1 colspan=1>Section 3 Reference safety architecture</td></tr><tr><td rowspan=1 colspan=1>D2.1 b)</td><td rowspan=1 colspan=1>Section 3.2 Compliant item</td></tr><tr><td rowspan=1 colspan=1>D2.1 c)</td><td rowspan=1 colspan=1>Section 3.2 Compliant item</td></tr><tr><td rowspan=1 colspan=1>D2.2 a)</td><td rowspan=6 colspan=1>General information are provided in Section 4.1 Random hardware failure safety results.Detaile information on failuremodes and relatefailure rates ar included inothereferencedocuments[1], [2] referred in Section 1.3 Reference documents.</td></tr><tr><td rowspan=1 colspan=1>D2.2 b)</td></tr><tr><td rowspan=2 colspan=1>D2.2 c)</td><td rowspan=2 colspan=1>Detailed information on fai</td></tr><tr><td rowspan=1 colspan=1>failure </td></tr><tr><td rowspan=1 colspan=1>D2.2 d)</td></tr><tr><td rowspan=1 colspan=1>D2.2 e</td></tr><tr><td rowspan=1 colspan=1>D2.2 f)</td><td rowspan=1 colspan=1>Useful information for DTI of each safety mechanisms are provided in related specification tables filedPeriodicity&quot;)of Section 3.6 Hardware and software diagnostics. General guidance on DT is includedinSection 3.3.1 Safety requirement assumptions.</td></tr><tr><td rowspan=1 colspan=1>D2.2 g)</td><td rowspan=1 colspan=1>Because of the software-based nature of Device safety concept, the outputs of the Compliant Itemtriggered by internal diagnostics are decided at application software level, and so they cannot bedescribed in this manual.</td></tr><tr><td rowspan=1 colspan=1>D2.2 h)</td><td rowspan=1 colspan=1>Periodic proof test is excluded by specific ASR3.1 in Section 3.3.1 Safety requirement assumptions</td></tr><tr><td rowspan=1 colspan=1>D2.2 i)</td><td rowspan=1 colspan=1>Section 3.7 Conditions of use</td></tr><tr><td rowspan=1 colspan=1>D2.2 j)</td><td rowspan=1 colspan=1>Section 3.2.3 Reference safety architectures - 1o01, Section 3.2.4 Reference safety architectures - 1002</td></tr><tr><td rowspan=1 colspan=1>D2.2 k)</td><td rowspan=1 colspan=1>Section 3.2.2 Safety functions performed by Compliant item</td></tr></table>

# 1.3

# Reference documents

[1] AN5100, Results of FMEA on STM32H7 single-core microcontrollers.   
[2] AN5099, Results of FMEDA on STM2H7 single-core microcontrollers.   
[3] AN5689: Adapting the X-CUBE-STL functional safety package or STM32 (IEC 61508 compliant) to other safety standards   
[4] AN5936 X-CUBE-STL: advanced topics

# 2 Device development process

ST2 sers product development process (eeFigure ), compliant with the IATF1649 standard,   s inteelatactivitedicateansorm customepeccationanmarkendusyomaiequnt in siducor deviced altcateelment packagmodule,susysteharare so, adocmentation) quald winteral rocedures tnteralubconractmanuacu technologies.

![](images/3fdaddc0b7d650673160aa326c43884b2468315786e48c27b8c9fe364795058a.jpg)  
Figure 1. STMicroelectronics product development process

# 3 Reference safety architecture

This section reports details of the STM32H7 single-core series safety architecture.

# Safety architecture introduction

The Devi()analyz hiocent an eussCopliantem()wihifent ey plns.

Te eal design aspects which are outside of the defined Compliant item.

As aconsequence  a Compliant itemapproach, the goal is to list he system-elated informatin considered urghenalyehan vi haustivhazar nnalyheystev. Such information includes, among others, application-relatedassumptions fordangerfactors, frequenc failures and diagnostic coverage guaranteed by the application.

# 3.2 Compliant item

Tplnne schemes.

# 3.2.1 Definition of Compliant item

According to IEC61508-1 clause 8.2.12, a Compliant item is any item orexample an element) n which  cai made wit epec  heclau h 0 .AnymatuCoplint itm must  e in a safety manual available to the End user.

Inhi document, Compliant tem  defined as a systemincluding one or two T32 devices ee Figure. The communication bus is directly or indirectly connected to sensors and actuators.

![](images/78bbc4f75aeb725b02f4dfe042852d6f2ac2759ead1f56b85d3a4d7a05b9fbcd.jpg)  
Figure 2. STM32 as Compliant item

Oe components might be relate  theCompliant itm, likethe external HW components needed to guarantee lv lc qu external watchdog or voltage supervisors).

A defined Compliant item can be classified as element according to IEC 61508-4, 3.4.5.

In summary, claims related to this Compliant item are related to the possible use of a Device for the with specific architectures and observing allthe requirements and indications provided in this manual.

# 3.2.2

# Safety functions performed by Compliant item

InenceCpliantrhitccpasheolloi oe peoighe eyc part of it:

input processing elements (PEi) reading safety related data from the remote controller connected to the sensor(s) and transferring them to the following computation elements   
computation processing elements (PEc) performing the algorithm required by the safety function and transferring the results to the following output elements

u posieeet traserrifeyelatathemoontroloe e actuator in 1oo2 architecture, potentially a further voting processing element (PEv) the computation processing elements can be involved (to the extent depending to the target safety interity) in the implementation o local softwarebased diagnostic functions; this srepresented bythe bock PEd • processes external to Compliant item ensuring safety integrity, such as watchdog (WDTe) and voltage monitors (VMONe)

Te lh    caSc3..Re afehTe WDTe and VMONe external processes is clarified under Section 3.6 Hardware and software diagnostics:

WDTe: refer to External watchdog - CPU_SM_5 and Control flow monitoring in Application software - CPU_SM_1,

VMONe: refer to Supply voltage internal monitoring (PVD) - VSUP_SM_1 and System-level power supply management - VSUP_SM_5.

In sumary, Devics support the mplementation Enduser safety unctions consisting  threeoperaions:

safe acquisition of safety-related data from input peripheral(s)   
safe execution of Application software program and safe computation of related data   
safe transfer of results or decisions to output peripheral(s)

Claims on Compliant item and computation of safety metrics are done with respect to these three basic operations.

# Caution:

uatag certain SIL is strongly correlated to the observance of CoUs as requested in Section 3.7 Conditions  use.

Acrdinghefiitn pleent aeyunctonsCompliant  lment) neregardesyB ( pe IEC1508-, 7..4.1.3 defintion). Desptaccurate,exhaustiveand detaiefailueanalysi, Devis to be considered as intrinsically complex. This implies its type B classification.

Two main safety architectures are identified: 1o01 (using one Device) and 1oo2 (using two Devices).

# Reference safety architectures - 1001

10reference architecture Figure )ensures safety integrity f Compliant item through combining Device internal processes (implemented safety mechanisms) with external processes WDTe and VMONe. 1001 reference architecture targets safety integrity level (SIL) SIL2.

![](images/e0d26c1cd17d3529b23b4be732ae825166149777b6e3db8cf8d2fe800d57615d.jpg)  
Figure 3. 1oo1 reference architecture

# 3.2.4

# Reference safety architectures - 1002

The 1o02 reference architecture (Figure ) contains two separate channels, either implemented as a 1001 reference architecture ensuring safety integrityof the Compliant item through combining Device internal processes (implemented safety mechanisms) with external processes: WDTe and VMONe. The overall safety l levasha uexi ietat oglpeauyon Ac hihe safetytegrit level s er EC50Table hereoe possible.Aporiateseparatin bw the ochans ncldig powersuply paration should beplemente irert avoid huge common-cause failures (refer to Section 4.Analysisfdependent failures). However, β and βD parameters computation is required.

Trut ae ollo tatI ay.hal e ablv two channels.

![](images/d99a8e4bcbb8b03c69e3b3b12e56859ed770acda7bf09d23ffaaf641a6bbff32.jpg)  
Figure 4. 1oo2 reference architecture

# 3.3

# Safety analysis assumptions

This section collects all assumptions made during the safety analysis of the Devices.

# 3.3.1

# Safety requirement assumptions

The safety concept specification, the overal safety requrement specification and the consequent aloatin determine the assumed requirements for Compliant item as further listed. ASR stands for assumed safety requirement.

# Caution:

It is End user's responsibiliy to check the compliance of the final application with these assumptions.

ARCompliant tem can  se implement four kindsafey function modesoperation accoring to IEC 61508-4, 3.5.16:

a continuous mode (CM) or high-demand (HD) SIL3 safety function (CM3), or a low-demand (LD) SIL3 safety function (LD3), or   
a CM or HD SIL2 safety function (CM2), or   
a LD SIL2 safety function (LD2).

ASRCopliant emus tomplement safey nction)allwing  spei wors-castie budgt e note below) or he 32 CU to detect and react o a failure.That time corresponds to the portion e Su ua level.

# Note:

The computation for time budget mainly depends on the execution speed for periodic tests implemented by software. Such duration might depends on the actual amount of hardware resources (RAM memory, flash memory, peripherals) actually declared as safety-related. Further constraints and requirements from IEC 61508-2, 7.4.5.3 must be considered.

![](images/ee0750552c02b88e21223d82eb08b8979bea6d07e76318e5040953a6aa433e26.jpg)  
Figure 5. Allocation and target for STM32 PST

An n iuoill proof tests.

A3. Ishat heDeviera with ecelcleitionsnvmetm.   
The End user is responsible for the compliance to this assumption.

As same SlL and therefore they are not distinguishable in terms of their safety requirements.

AIn ultipypats  ausibleu ensure their mutual independence.

ASR:I is assumed that there are o non-safety-related functions implemented inApplication software, coexisting with safety functions.

Note:

This assumption i stateddueo the lack  hardware-basedmechanisms able to completely isolatenonaey related software. Software-based isolation solutions are not forbidden.

hatn)o  e from a low-power state.

ASR8:After the emergence of a fault, the local safe state of Compliant item is the one in which either:

SSApplication software is informed by the presence of a fault and a reaction by Application software itself is possible.   
Application softwarecannot be informed by the presence  a fault orApplication software is ot able to execute a reaction.

# Note:

For a correct implementation of fault reaction, the End user must be aware that random hardware failures affecting the Device can compromise its operation (for example failure modes affecting the program counter may prevent the correct execution of the software). Accordingly, software-based transitions to a safe state must be carefully evaluated. Refer to [4] for additional details.

The following table provides details on the SS1 and SS2 safe states.

Table 2. SS1 and SS2 safe state details   

<table><tr><td rowspan=1 colspan=1>Safestate</td><td rowspan=1 colspan=1>Condition</td><td rowspan=1 colspan=1>Compliant itemaction</td><td rowspan=1 colspan=1>System transition to safestate  1001 architecture</td><td rowspan=1 colspan=1>System transition to safestate  1o02 architecture</td></tr><tr><td rowspan=1 colspan=1>SS1</td><td rowspan=1 colspan=1>Application software is informedby the presence of a fault and areaction by Application softwareitself is possible.</td><td rowspan=1 colspan=1>Fault reporting toApplicationsoftware</td><td rowspan=1 colspan=1>Application software drivesthe overall system in its safestate</td><td rowspan=1 colspan=1>Application software in one ofthe two channels drives theoverall system in its safe state</td></tr><tr><td rowspan=1 colspan=1>SS2</td><td rowspan=1 colspan=1>Application software cannot beinformed by the presence of afault or Application software is notable to execute a reaction.</td><td rowspan=1 colspan=1>Reset signalissued by WDTe</td><td rowspan=1 colspan=1>WDTe drives the overallsystem in its safe state (&quot;safeshut-down&quot;) (1)</td><td rowspan=1 colspan=1>PEv drives the overall systemin its safe state</td></tr></table>

1. Safe state achievement intended here is compliant to Note on IEC 61508-2, 7.4.8.1

ha  s vi safe state (SS1, SS2) for Compliant item.

ASR10: Compliant item is assumed to be analyzed according to routes 1H and 1S of IEC 61508-2.

Refer to Section 3.5 Systematic safety integrity and Section 3.6 Hardware and software diagnostics

ASR11: Compliant item is assumed to be regarded as type B, as per IEC 61508-2, 7.4.4.1.3.

ASR12: It is assumed that dual-bank flash memory mass erase and reprogramming features are used during maintenance state of the final system, and not for the implementation of the safety function.

A hathealuatonhazar elatnacoremisucur related to the use of the Compliant item is under the full responsibility of the End user.

# Electrical specifications and environment limits

To ensure safety integrity, the user must operate Device(s) within its (their) specified:

absolute maximum rating capacity operating conditions

Flltvl ml as datasheet(s) and reference manual(s) available on www.st.com.

# Note:

The device operation within specified limits is a prerequisite for the correct mplementation of any safety function. This is explicitly assumed within the assumptions (refer to above ASR3.2).

# 3.5

# Systematic safety integrity

According to the requirements of the IEC 61508-2,7.4.2.2 clause, the Route 1 is considered in the safety analysis of Device(s). As authorized by the IEC 61508-2, 7.4.6.1 clause, the STM32 MCU products can be considered as standard, mass-produced electronic integrated devices, for which stringent development ottice u ST internally assesses the compliance of the Device development flow, through techniques and measures suggested in the IEC 61508-2 Annex F. As highly confidential information on ST processes are concerned withi the lctiv t c)ev compliance level to the standard.

# 3.6

# Hardware and software diagnostics

Tn  yanptn-e a used in conjunction with the related Device datasheet, user manual and reference information. To avoid inconsistency and redundancy, this document does not report device functional details. In the following descriptions, the words safety mechanism, method, and requirement are used as synonyms.

Aeocent provioaion elatieper perhealvailableviv (no all devices have all peripherals), users are supposed t disregard any recommendations ot applicable to their Device part number of interest.

Ina iepli he Refer to its reference manual or/and datasheet for related information.

Tplntatin guliorheolli ctio oeercnyTeay valav elated documents)are based n such guidelnes. Forclariy, sfety mechanisms are grouped by Device function.

Information is organized in form of tables, one per safety mechanism, with the following fields:

<table><tr><td>SM CODE</td><td>Unique safety mechanism code/identifier used also in FMEA document. Identifiers use the scheme mmm_ SM_x where mmm is a 3- or 4-letter module (function, peripheral) short name, and x is a</td></tr><tr><td></td><td>number. It is possible that the numbering is not sequential (although usually incremental) and/or that the module short name is different from that used in other documents.</td></tr><tr><td>Description</td><td>Short mnemonic description ST: method is available on silicon.</td></tr><tr><td rowspan="2">Ownership</td><td>End user: method must be implemented by End user through Application software modification,</td></tr><tr><td>hardware solutions, or both. Detailed implementation sometimes including notes about the safety concept behind the introduction</td></tr><tr><td>Detailed implementation</td><td>of the safety mechanism.</td></tr><tr><td>Error reporting</td><td>Describes how the fault detection is reported to Application software.</td></tr><tr><td>Fault detection time</td><td>Time that the safety mechanism needs to detect the hardware failure. Reports fault model(s) addressed by the diagnostic (permanent, transient, or both), and other</td></tr><tr><td rowspan="3">Addressed fault model</td><td>information:</td></tr><tr><td>If ranked for Fault avoidance: method contributes to lower the probability of occurrence of a failure If ranked for Systematic: method is conceived to mitigate systematic errors (bugs) in</td></tr><tr><td>Application software design Reports if safety mechanism implementation or characteristics change among different Device part</td></tr><tr><td>Dependency on Device configuration</td><td>numbers.</td></tr><tr><td>Initialization</td><td>Specific operation to be executed to activate the contribution of the safety mechanism</td></tr><tr><td>Periodicity</td><td>Continuous : safety mechanism is active in continuous mode. Periodic: safety mechanism is executed periodically(1).</td></tr><tr><td></td><td>On-demand: safety mechanism is activated in correspondence to a specified event (for instance,</td></tr><tr><td></td><td>reception of a data message). Startup: safety mechanism to be executed only at power-up or during offline maintenance periods.</td></tr><tr><td>Test for the</td><td>This is due to functional-only aspects or due to the poor compatibility with the correct execution of the safety function. Reports specific procedure (if any and recommended) to allow on-line tests of safety mechanism</td></tr><tr><td>diagnostic Multiple-fault</td><td>efficiency. If no specific procedure applies (as for the majority of safety mechanisms), the field indicates Not applicable.</td></tr><tr><td>protection</td><td>Reports the safety mechanism(s) associated in order to correctly manage a multiple-fault scenario (refer to Section 4.1.3 Notes on multiple-fault scenario).</td></tr><tr><td>Recommendations and known limitations</td><td>Additional recommendations or limitations (if any) not reported in other fields.</td></tr></table>

# 3.6.1 Arm® Cortex®-M7 CPU

Table 3. CPU_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=2>CPU_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td></td><td></td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=2>End user or ST (X-CUBE-STL, see Appendix A)</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=2>The software test is built around well-known techniques already addressed by IEC 61508-7,A.3.2 (Self-test by software: walking bit one-channel). To reach the required values ofcoverage, the self-test software is specified by means of a detailed analysis of all the CPUfailure modes and related failure modes distribution.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=2>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=2>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=2>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=2>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=2>None</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=2>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=2>Self-diagnostic capabilities can be embedded in the software, according to the testimplementation design strategy chosen. The adoption of checksum protection on resultsvariables and defensive programming are recommended.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=2>CPU_SM_5: External watchdog</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=2>This method is the main asset in STM32H7 single-core series safety concept. Hardwareintegrity of the CPU is a key factor, given that the defined diagnostics for MCU peripherals areto major part software-based.Startup execution of this safety mechanism is recommended for multiple fault mitigations -refer to Section 4.1.3 Notes on multiple-fault scenario for details.</td></tr></table>

Table 4. CPU_SM_1   

<table><tr><td></td><td rowspan=3 colspan=1>CPU_SM_1Control flow monitoring in Application software.</td></tr><tr><td rowspan=1 colspan=1>SM CODE</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>A significant part of the failure distribution of CPU core for permanent faults is related to failuremodes directly related to program counter loss of control or hang-up. Due to their intrinsicnature, such failure modes are not addressed by a standard software test method likeSM_CPU_0. Therefore, it is necessary to implement a run-time control of Application softwareflow in order to monitor and detect deviation from the expected behavior due to such faults.Linking this mechanism to watchdog firing assures that severe loss of control (or, in the worstcase, a program counter hang-up) is detected.The guidelines for the implementation of the method are the following:Different internal states of Application software are well documented and described (theuse of a dynamic state transition graph is encouraged).Monitoring of the correctness of each transition between different states of Applicationsoftware is implemented.Transition through all expected states during the normal Application software programloop is checked.A function in charge of triggering the system watchdog is implemented in order toconstrain the triggering (preventing the issue of CPU reset by watchdog) also to thecorrect execution of the above-described method for program flow monitoring. The useof window feature available on internal window watchdog (WWDG) is recommended.The use of the independent watchdog (IWDG), or an external one, helps to implement amore robust control flow mechanism fed by a different clock source.In any case, safety metrics do not depend on the kind of watchdog in use (the adoption ofindependent or external watchdog contributes to the mitigation of dependent failures, seeSection 4.2.2 Clock).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation. Higher value is fixed by watchdog timeout interval.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

Table 5. CPU_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>CPU_SM_2Double computation in Application software</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>A timing redundancy for safety-related computation is considered to detect transient faultsaffecting the Arm®Cortex®-M7 CPU subparts devoted to mathematical computations and dataaccess.The guidelines for the implementation of the method are the following:The requirement needs be applied only to safety-relevant computation, which in case ofwrong result could interfere with the system safety functions. Such computation must betherefore carefully identified in the original Application software source codeBoth mathematical operation and comparison are intended as computation.The redundant computation for mathematical computation is implemented by usingcopies of the original data for second computation, and by using an equivalent formulaif possible</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>End user is responsible to carefully avoid that the intervention of optimization features of theused compiler removes timing redundancies introduced according to this condition of use.Reduction to the application scope for this method is achieved by executing an accuratesafety analysis of the software. Refer to [4] for details. However, the scope reduction may notbe possible nor desirable.</td></tr></table>

Table 6. CPU_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Arm®Cortex®-M7 HardFault exceptions</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>HardFault exception raise is an intrinsic safety mechanism implemented in Arm®Cortex®-M7core, mainly dedicated to intercept systematic faults due to software limitations or error insoftware design (causing for example execution of undefined operations, unaligned addressaccess). This safety mechanism is also able to detect hardware random faults inside the CPUbringing to such described abnormal operations.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>High-priority interrupt event</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation. Refer to functional documentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>It is possible to write a test procedure to verify the generation of the HardFault exception;anyway, given the expected minor contribution in terms of hardware random-failure detection,such implementation is optional.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Enabling related interrupt generation on the detection of errors is highly recommended.</td></tr></table>

Table 7. CPU_SM_4   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CPU_SM_4</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Stack hardening for Application software</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The stack hardening method is required to address faults (mainly transient) affecting CPUregister bank. This method is based on source code modification, introducing informationredundancy in register-passed information to called functions.The guidelines for the implementation of the method are the following:To pass also a redundant copy of the passed parameters values (possibly inverted) andto execute a coherence check in the function.To pass also a redundant copy of the passed pointers and to execute a coherencecheck in the function.For parameters that are not protected by redundancy, to implement defensiveprogramming techniques (plausibility check of passed values). For exampleenumerated fields are to be checked for consistency.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method partially overlaps with defensive programming techniques required by IEC 61508for software development. Therefore in presence of Application software qualified for safetyintegrity greater or equal to SC2, optimizations are possible.</td></tr></table>

Table 8. CPU_SM_5   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>CPU_SM_5External watchdog</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Using an external watchdog linked to control flow monitoring method (refer to CPU_SM_1)addresses failure mode of program counter or control structures of CPU.External watchdog can be designed to be able to generate the combination of signals neededon the final system to achieve the safe state. It is recommended to carefully check theassumed requirements about system safe state reported in Section 3.3.1 Safety requirementassumptions.Compared to the MCU internal watchdogs, it is not affected by potential common causefailures, because the external watchdog is clocked and supplied independently of Device.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation (watchdog timeout interval)</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>To be defined at system level (outside the scope of Compliant item analysis).</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_1: Control flow monitoring in Application software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>In case of usage of windowed watchdog, End user must consider possible tolerance inApplication software execution to avoid false error reports (affecting system availability).It is worth noting that the use of an external watchdog is needed when Device is used totrigger final elements, in order to comply at system level with requirements fromIEC 61508-2:2010 Table A.1/Table A.14.</td></tr></table>

Table 9. CPU_SM_6   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CPU_SM_6</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Independent watchdog</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Using the IDWG watchdog linked to control flow monitoring method (refer to CPU_SM_1)addresses failure mode of program counter or control structures of CPU.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Reset signal generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation (watchdog timeout interval)</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>IWDG activation. It is recommended to use hardware watchdog in option byte settings (IWDGis automatically enabled after reset).</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>WDG_SM_1: Software test for watchdog at startup</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_1: Control flow monitoring in Application softwareWDG_SM_0: Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>The IWDG intervention is able to achieve a potentially &quot;incomplete&quot; local safe state because itcan only guarantee that CPU is reset. No guarantee that Application software can be stillexecuted to generate combinations of output signals that might be needed by the externalsystem to achieve the final safe state. If this limitation turn out in a blocking point, End usermust adopt CPU_SM_5.</td></tr></table>

Table 10. CPU_SM_7   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CPU_SM_7</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Memory protection unit (MPU).</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The CPU memory protection unit is able to detect ilegal access to protected memory areas,according to criteria set by End user.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Exception raise (MemManage).</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to functional documentation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Systematic (software errors)Permanent/transient (only program counter and memory access failures)</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>MPU registers must be programmed at start-up.</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On line</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>MPU_SM_1: MPU software test</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>MPU_SM_0: Periodic read-back of MPU configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>The use of memory partitioning and protection by MPU functions is highly recommendedwhen multiple safety functions are implemented in Application software. The MPU can beindeed used toenforce privilege rulesseparate processesenforce access rulesHardware random-failure detection capability for MPU is restricted to well-selected failuremodes, mainly affecting program counter and memory access CPU functions. The associateddiagnostic coverage is therefore not expected to be relevant for the safety concept of Device.</td></tr></table>

Table 11. CPU_SM_9   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CPU_SM_9</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic self-test software for Arm®Cortex® -M7 caches</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user or ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The software test is built around well-known techniques already addressed by IEC 61508-7,A.3.2 (Self-test by software: walking bit one-channel).The scope of the software test arefailure modes affecting Arm®Cortex® -M7 L1 caches controllers.The achieved diagnostic coverage strongly depends on the complexity of the testimplementation, and on the percentage of caches failure modes addressed.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_5: External watchdog</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Ei simplifications in STM32H7 single-core series safety concept:•    No need to implement this method (CPU_SM_9)Decrease of Arm®Cortex® -M7 overall failure rate.</td></tr></table>

Table 12. CPU_SM_10   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CPU_SM_10</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>ECC on Arm®Cortex® -M7 caches</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>ECC on Arm®Cortex® -M7 L1 cache memories (data and instructions) are protected by anEC ror correction code redundancy, implementing a protection feature t double-word (bit) level:•    one-bit fault: correction•    two-bit fault: detection</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error correction/detection is reported in IEBR0/1 and DEBR0/1 registers.Refer to Arm®documentation.</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>ECC bits are checked during cache usage</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for ECC efficiency is not available. ECC run-time hardware failuresleading to the disable of such protection, or to wrong corrections, fall into a &quot;multiple faultscenario&quot; from IEC 61508 perspective. Related failures are adequately mitigated by thecombination of safety mechanisms reported in this table, feld Multiple-fault protection. Readalso the note on Recommendations and known limitations field.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_1: Control flow monitoring in Application softwareCPU_SM_3: Arm®Cortex®-M7 HardFault exceptionsCPU_SM_4: Stack hardening for Application softwareRAM_SM_3: Information redundancy for safety-related variables in the Application software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Because of the lack of ECC direct test procedure, single-fault failures leading to unintendedECC correction may cause an incorrect data read from Flash memory. This is why STM32H7single-core series safety concept strongly recommends the adoption of multiple layers ofoverlapped safety mechanisms which collaborate to mitigate such kind of ECC failures. Refer [] or details on ECC failure mitigation strategy.</td></tr></table>

Table 13. MPU_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>MPU_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of MPU configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to MPU configuration registers (also unused by EnduserApplication software).Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 14. MPU_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>MPU_SM_1MPU software test</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method tests MPU capability to detect and report memory accesses violating the policyenforcement implemented by the MPU itself.The implementation is based on intentionally performing read and write accesses outside thememory areas allowed by the MPU region programming, and collecting and verifying relatedgenerated error exceptions.Test can be executed with the final MPU region programming or with a dedicated one.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Startup execution of this safety mechanism is recommended for multiple fault mitigations -refer to Section 4.1.3 Notes on multiple-fault scenario.</td></tr></table>

# 3.6.2 System bus architecture/BusMatrix

Table 15. BUS_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>BUS_SM_0Periodic software test for interconnections</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The intra-chip connection resources (Bus Matrix, AHB or APB bridges) needs to beperiodically tested for permanent faults detection. Note that STM32H7 single-core seriesdevices have o hardware safety mechanism to protect these structures.The test executes aconnectivity test of these shared resources, including the testing of the arbitrationmechanisms between peripherals.According to IEC 61508-2 Table A.8, A.7.4 the method is considered able to achieve highlevels of coverage.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Implementation can e cnsidered i large part as overlapping with he widely used Peicread-back of configuration registers required for several peripherals.</td></tr></table>

Table 16. BUS_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>BUS_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy in intra-chip data exchanges</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method requires to add some kind of redundancy (for example a CRC checksum atpacket level) to each data message exchanged inside Device.Message integrity isverified using the checksum by the Application software, beforeconsuming data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Implementation can be in large part overlapping with other safety mechanisms requiringinformation redundancy on data messages for communication peripherals. Optimizations aretherefore possible.</td></tr></table>

# 3.6.3 Embedded SRAM

Table 17. RAM_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>RAM_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic software test for static random access memory (SRAM)</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user or ST (X-CUBE-STL, see Appendix A)</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>To enhance the coverage on SRAM data cells and to ensure adequate coverage forpermanent faults affecting the address decoder it is required to execute a periodic softwaretest on the system RAM memory. The selection of the algorithm must ensure the target SFFcoverage for both the RAM cells and the address decoder. Evidences of the effectiveness ofthe coverage of the selected method must also be collected</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>RAM size can change according to the part number.</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Self-diagnostic capabilities can be embedded in the software, according to the testimplementation design strategy chosen.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Usage of a March test C- is recommended.Because the nature of this test can be destructive, RAM contents restore must beimplemented. Possible interferences with interrupt-serving routines fired during test executionmust be also considered (such routines can access to RAM invalid contents).Startup execution of this safety mechanism is recommended for multiple fault mitigations -refer to Section 4.1.3 Notes on multiple-fault scenario.Unused RAM section can be excluded by the testing, under End user responsibility on actualRAM usage by final Application software.</td></tr></table>

Table 18. RAM_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>RAM_SM_2Stack hardening for Application software</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The stack hardening method is used to enhance the Application software robustness to SRAMfaults that affect the address decoder. The method is based on source code modification,introducing information redundancy in the stack-passed information to the called functions.Method contribution is relevant in case the combination between the final Application softwarestructure and the compiler settings requires a signifiant use of thestack or passig fncionparameters.Implementation is the same as method CPU_SM_4.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to CPU_SM_4</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to CPU_SM_4</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to CPU_SM_4</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to CPU_SM_4</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to CPU_SM_4</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to CPU_SM_4</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to CPU_SM_4</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to CPU_SM_4</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to CPU_SM_4</td></tr></table>

Table 19. RAM_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>RAM_SM_3Information redundancy for safety-related variables in the Application software</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>To address transient faults affecting the SRAM controller and memory cells, it is required toimplement information redundancy on the safety-related system variables stored in the SRAM.The guidelines for the implementation of this method are the following:The system variables that are safety-related (in the sense that a wrong value due to afailure in reading on the RAM affects the safety functions) are well-identified anddocumented.The arithmetic computation or decision based on such variables are executed twice andthe two final results are compared.Safety-related variables are stored and updated in two redundant locations, andcomparison is checked before consuming data.Enumerated fields must use non-trivial values, checked for coherence with the samefrequency as for periodically executed diagnostics (see (1) in Section 3.6 Hardware andsoftware diagnostics).Data vectors stored in SRAM must be protected by an encoding checksum (such asCRC).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Implementation of this safety method shows a partial overlap with an already foreseen methodfor Arm® Cortex®-M7 (CPU_SM_2); optimizations in implementing both methods aretherefore possible.Reduction to the application scope for this method is achieved by executing an accuratesafety analysis of the software. Refer to [4] for details. However, the scope reduction may notbe possible nor desirable.</td></tr></table>

Table 20. RAM_SM_4   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>RAM_SM_4</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Control flow monitoring in Application software</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>In case End user Application software is executed from SRAM, permanent and transient faultsaffecting the memory (cells and address decoder) can interfere with the program execution.The implementation of this method is required to address such failures.For more details on the implementation, refer to CPU_SM_1 description.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation. Higher value is fixed by watchdog timeout interval.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Needed only in case of Application software execution from SRAM.CPU_SM_1 correct implementation supersedes this requirement.</td></tr></table>

Table 21. RAM_SM_5   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>RAM_SM_5Peridic integrity test for Application software in RAM</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>In case Application software or diagnostic libraries are executed in RAM, it is needed toprotect the integrity of the code itself against soft-error corruptions and related codemutations. This method must check the integrity of the stored code by checksum computationtechniques, on a periodic basis. For implementation details, refer to similar methodFLASH_SM_0.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Self-diagnostic capabilities can be embedded in the software, according to the testimplementation design strategy chosen.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test softwareCPU_SM_1: Control flow monitoring in Application software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Thimethod mustnly bplemented Application softwaredignost librari executed from RAM.</td></tr></table>

Table 22. RAM_SM_6   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>RAM_SM_6</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Read protection (RDP) and write protection (WRP)</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>SRAM can be protected against illegal reads or erase/write by using these protection features.The combination of these techniques and the related different protection level allows End userto build an effective access protection policy.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to functional documentation - in some cases a HardFault error is generated.</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to functional documentation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Systematic</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Not required</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Not required</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Hardware random-failure detection capability for SRAM2 access policy is restricted to well-selected marginal failure modes, mainly affecting program counter and SRAM2 interfacefunctions. The associated diagnostic coverage is therefore expected to be irrelevant in theframework of STM32H7 single-core series safety concept.</td></tr></table>

Table 23. RAM_SM_7   
The FMEDA snapshot document includes information on recommended frequency.   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>RAM_SM_7</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>ECC on SRAM</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Internal SRAM is protected by an ECC (error correction code) redundancy implementing aprotection feature at double-word (64 bit) level:one-bit fault: correctiontwo-bit fault: detection</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to functional documentation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>ECC bits are checked during a memory reading.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for ECC efficiency is not available. ECC run-time hardware failuresleading to disabling the diagnostic, or leading to wrong corrections, fall into multiple-faultscenario, from IEC 61508 perspective. Related failures are adequately mitigated by thecombination of safety mechanisms reported in this table, field Multiple-fault protection.Also refer to reference [4]for further information.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>RAM_SM_0: Periodic software test for static random access memory (SRAM)(1)DIAG_SM_0: Periodic read-back of hardware diagnostics configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Note that because the ECC is checked during memory reads, RAM locations occupied by thesafety related data which are rarely accessed (for instance, variables and/or code related tofailures/errors management) are potentially exposed to the risk of error accumulation. In sucha case, t is recommended to periodically check those locations by a memory scrubbing (bysimply reading memory to reveal error correction or detection).The single error correction performed by the ECC is done just on the data read from thememory, but the value stored in the memory cells is not automatically corrected. To completelyremove the error, a rewrite on the memory location with correct data is needed.Important:    Due to the lack of direct ECC test procedure, single-fault failures leading tounintended ECC corrections may cause an incorrect data read frommemory. This is why STM32H7 safety concept strongly recommends theadoption of multiple layers of overlapped safety mechanisms whichcollaborate to mitigate such kind of ECC failures. Refer to [1] and [4] forfurther detailed information on ECC failures mitigation strategy.</td></tr></table>

Table 24. RAM_SM_8   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>RAM_SM_8</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic test by software for SRAM address decoder</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user or ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Permanent faults affecting the SRAM interfaces address decoder are addressed through adedicated software test that checks the memory cells contents versus the expected value.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>SRAM size depends on the part number</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Not required</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Overlaps with RAM_SM_0 implementation are possible.</td></tr></table>

# 3.6.4 Embedded flash memory

Table 25. FLASH_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FLASH_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Peric sotare est or fashmemoy</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user or ST (X-CUBE-STL, see Appendix A)</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Permanent faults affecting the system flash memory, memory cells, and address decoder areaddressed through a dedicated software test that checks the memory cells contents versusthe expected value, using signature-based techniques. According to IEC 61508-2 Table A.5,the effective diagnostic coverage of such techniques depends on the width of the signature inrelation to the block length of the information to be protected - therefore the signaturecomputation method is to be carefully selected. Note that the simple signature method(IEC 61508-7 - A.4.2 Modified checksum) is inadequate as it only achieves a low value ofcoverage.The information block does not need to be addressed with this test as it is not used duringnormal operation (no data nor program fetch).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Flash memory size changes according to the part number.</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Memory signatures must be stored in flash memory as well.</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Self-diagnostic capabilities can be embedded in the software, according to the testimplementation design strategy chosen.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test softwareCPU_SM_1: Control flow monitoring in Application software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This test is expected to have a relevant time duration — test integration must thereforeconsider the impact on Application software execution.The use of internal cyclic redundancy check (CRC) module is recommended. In principledirect memory access (DMA) feature for data transfer can be used.Unused flash memory sections can be excluded from testing.Startup execution of this safety mechanism is recommended for multiple fault mitigations -refer to Section 4.1.3 Notes on multiple-fault scenario for details.</td></tr></table>

Table 26. FLASH_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FLASH_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Control flow monitoring in Application software</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Permanent and transient faults affecting the system flash memory, memory cells and addressdecoder, can interfere with the access operation by the CPU, leading to wrong data orinstruction fetches.Such failures can be detected by control flow monitoring techniques implemented inApplication software loaded from flash memory.For more details on the implementation, refer to description CPU_SM_1.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation. Higher value is fixed by watchdog timeout interval.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>CPU_SM_1 correct implementation supersedes this requirement.</td></tr></table>

Table 27. FLASH_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>FLASH_SM_2Arm®Cortex®-M7 HardFault exceptions</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Hardware random faults (both permanent and transient) affecting system flash memorymemory cells, address decoder) can lead to wrong instruction codes fetches, and eventuallyto the intervention of the Arm®Cortex®-M7 HardFault exceptions. Refer to CPU_SM_3 fordetailed description.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr></table>

Table 28. FLASH_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>FLASH_SM_3Option byte write protection</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This safety mechanism prevents unintended writes of the option byte. The use of this methodis encouraged to enhance the end application robustness with respect to systematic faults.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Write protection exception</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>None (systematic only)</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Not required (enabled by default)</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Tmeoeysauapliinn aultn yao l.</td></tr></table>

Table 29. FLASH_SM_4   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FLASH_SM_4</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Static data encapsulation</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>tcapability (such as CRC) must be implemented.Checksumalidihecke Apliatiotaestatdatn</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

Table 30. FLASH_SM_6   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FLASH_SM_6</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Flash memory unused area iling code</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Used flash memory area must be flled with deterministic data. This way in case that the  uCPU, the system evolves in a deterministic way.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>None (fault avoidance)</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Filling code can be made of NOP instructions, or an illegal code that leads to a HardFaultexception raise.</td></tr></table>

Table 31. FLASH_SM_7   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FLASH_SM_7</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>ECC on flash memory</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Internal Flash memory is protected by ECC (error correction code) redundancy,implementinga protection feature at double-word (64 bit) level:one-bit fault: correctiontwo-bit fault: detection</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Correction:SNECCERR1/2 flag (ECC correction) is set in the FLASH_SR1/2 register.Interrupt is generated.Detection:DBECCERR1/2 flag (ECC detection) is set in the FLASH_SR1/2 register.Bus error is generated.The address of the failing double word is saved in the FLASH_ECC_FA1R/2R register.</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>ECC bits are checked during a memory reading.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for ECC efficiency is not available. ECC run-time hardware failuresleading to disabling the diagnostic, or leading to wrong corrections, fall into multiple-faultscenario, from IEC 61508 perspective. Related failures are adequately mitigated by thecombination of safety mechanisms reported in this table, field Multiple-fault protection.Also refer to the Recommendations and known limitations field.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>FLASH_SM_0: Periodic software test for flash memoryDIAG_SM_0: Periodic read-back of hardware diagnostics configuration registersCPU_SM_3: Arm®Cortex®-M7 HardFault exceptions</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Enabling related interrupt generation on the detection of errors is highly recommended.Because of the lack of ECC direct test procedure, single-fault failures leading to unintendedECC correction may cause an incorrect data read from the Flash memory. This is why theSTM32H7 single-core series safety concept strongly recommends the adoption of multiplelayers of overlapping safety mechanisms which collaborate to mitigate such kind of ECCir. Refer or details n CC ailuemitation ry.</td></tr></table>

Table 32. FLASH_SM_8   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FLASH_SM_8</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Read protection (RDP), write protection (WRP), and proprietary code readout protection(PCROP)</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Flash memory can be protected agains llegal read or erase/write accesses byusing thesepoction tuiation hnqu nelat iffen provl allowsEd usero buil nfectivcc rotion oy.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to functional documentation.In some cases, a HardFault error is generated.</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to functional documentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Systematic</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Not required</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Not required</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Hardware random-failure detection capability for Flash memory access policy is restricted towell-selected marginal failure modes, mainly aecting program counter and Flash memoryinterface functions. The associated diagnostic coverage is therefore expected to be irrelevantin the framework ofSTM32H7 single-core series safety concept.</td></tr></table>

Table 33. FLASH_SM_9   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FLASH_SM_9</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Peric est b software or fashmemory addess decer</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Permanent faults afecting the system flash memory interface address decoder are addressedthrough a dedicated software test that checks the memory cells contents versus the expectedvvalue.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>flash memory size depends on part number.</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Not required</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Overlaps with FLASH_SM_0 implementation are possible.</td></tr></table>

# 3.6.5 Power controller (PWR)

Table 34. VSUP_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>VSUP_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 35. VSUP_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>VSUP_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Supply voltage internal monitoring (PVD)</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The device features an embedded programmable voltage detector (PVD) that monitors theVDD power supply and compares it to the VpvD threshold. An interrupt can be generated whenVDD drops below the VpVD threshold or when VDD is higher than the VpVD threshold.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Interrupt event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on threshold programming. Refer to functional documentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Protection enable by the PVDE bit and the threshold setting in the Power control register(PWR_CR)</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for PVD efficiency is not available. PVD run-time hardware failuresleading to disabling such protection fallinto multiple-fault scenario, from IEC 61508perspective. Related failures are adequately mitigated by the combination of safetymechanisms reported in this table, field Multiple-fault protection.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>DIAG_SM_0: Periodic read-back of hardware diagnostics configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Internal monitoring PVD has limited capability to address failures affecting STM32H7 single-core series internal voltage regulator. Refer to [1] for details.Internal monitoring PVD has limited capabiliy to address failures affecting the internal voltageregulator. Refer to Device FMEA for details.In case the hardware option is not available on the chosen partnumbers, its contribution to theoverall safety concept is supported by other overlapping methods indicated for the mitigationof failures affecting internal power.</td></tr></table>

Table 36. VSUP_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>VSUP_SM_2Independent watchdog</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Failures in the power supplies for digital logic (core or peripherals) may lead to alteration ofApplication software timing, which can be detected by IWDG as safety mechanism introducedto monitor the Application software control flow. Refer to CPU_SM_1 and CPU_SM_6 forfurther information.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Reset signal generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation (watchdog timeout interval)</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>IWDG activation. It is recommended to use Hardware watchdog in Option byte settings (IWDGis automatically enabled after reset).</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to CPU_SM_6.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_1: Control flow monitoring in Application software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>In specific part numbers, IWDG can be fed by a power supply independent from the one usedfor U core and main peripherals. Such diversity helps ncrease the protection guarantedby IWDG from main power supply anomalies.The adoption of an external watchdog (refer to CPU_SM_5) adds further diversity.</td></tr></table>

Table 37. VSUP_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>vSUP_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Internal temperature sensor check</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The internal temperature sensor must be periodically tested in order to detect abnormalincrease of the die temperature - hardware faults in supply voltage system may causeexcessive power consumption and consequent temperature rise.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method also mitigates the probability of common-cause failure due to excessivetemperature, affecting the Device.Refer to the Device datasheet to set the threshold temperature.</td></tr></table>

Table 38. VSUP_SM_5   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>VSUP_SM_5</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>System-level power supply management</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1> nil value over time. It can include a combination of different overlapped solutions, some listedhere below (but not limited to):additional voltage monitoring by external componentspassive electronics devices able to mitigate overvoltagespecific design of power regulator in order to avoid power supply disturbance inpresence of a single failure</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Fault avoidance</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Usually, hmethod aready quremplemente o guaranteehestabilityaccomponent of the final electronic board.</td></tr></table>

# 3.6.6 Reset and clock controller (RCC)

# Table 39. CLK_SM_0

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CLK_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to configuration registers for clock and reset system (refer toRCC register map).Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 40. CLK_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CLK_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Clock security system (CSS)</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The clock security system (CSS) detects the loss of high-speed external (HSE) oscillator clockactivity and executes the corresponding recovery action, such as:switch-off HSEcommutation on the HSI•    generation of related NMI</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>NMI</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation (clock frequency value)</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>CSS protection must be enabled through Clock interrupt register (RCC_CIR) after boot.</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_5: External watchdogCLK_SM_0: Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is recommended to carefully read reference manual instruction on NMIl generation, in orderto correctly managing the faulty situation by Application software.As the test of the diagnostic is not available in the hardware, it must be done at system levelduring startup or maintenance period. The use of this method to implement fail operationalschemes is not recommended.</td></tr></table>

Table 41. CLK_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CLK_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Independent watchdog</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The independent watchdog IWDG is able to detect failures i internal main MCU clock (lowerfrequency).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Reset signal generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation (watchdog timeout interval)</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>IWGactivation. Its recommended o use thehardware watchdog inOption byte sttingsWDG s utoatically nabled after ).</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to CPU_SM_6.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_1: Control flow monitoring in Application software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Tdotonan eteal watgreeMds urther ivy.</td></tr></table>

Table 42. CLK_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CLK_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Internal clock cross-measurement</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is implemented using general-purpose timers capabilities to be fed by the 32 KHzRTC clock or an external clock source (if available). Timer counter progress is compared withl coc alabe detected.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_1: Control flow monitoring in Application softwareCPU_SM_5: External watchdog</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Efnc vssn ulteggibl I ovielymeeficnc  eclock-related failure mode coverage.</td></tr></table>

# 3.6.7

# Clock recovery system (CRS)

No safety mechanisms are defined for CRS because of the consequences of CoU_8 (refer to Section 3.7 Conditions of use). CRS deactivation is guaranteed by Section 3.6.51 Disable and periodic crosscheck of unintentional activation of unused peripherals.

# 3.6.8 Hardware semaphore (HSEM)

Table 43. HSEM_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>HSEM_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to HSEM configuration registers.Detailed information on the implementation of this method can be found inSection 3.6. Extended interrupt and events controller XT).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 44. HSEM_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>HSEM_SM_1Control flow monitoring for concurrent tasks</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is intended to monitor the correct execution of software tasks that use the HSEMsemaphore method for their synchronization. The method is implemented by software,leveraging on the presence of a system watchdog (internal or external).The watchdog periodic reset function must be constrained to the correct timing execution oeach software task synchronized by semaphores.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation. Higher value is fixed by watchdog timeout interval.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method must be extended to any software task using an HSEM semaphores function forsynchronization, regardless task nature (safety relevant or non-safety relevant).Implementation must take into account potential overlaps/optimizations with CPU_SM_1.</td></tr></table>

# 3.6.9 General-purpose input/output (GPIO)

# Table 45. GPIO_SM_0

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>GPIO_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to GPIO configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>GPIO availability can differ according to part number</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>The execution of the method before any update on GPlO registers helps to mitigate thepossibility of unintended glitches on outputs due to soft errors. For more information refer to[4].</td></tr></table>

Table 46. GPIO_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>GPIO_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>1002 for input GPIO lines</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method addresses GPIO lines used as inputs. Implementation is done by connecting theexternal safety-related signal to two independent GPlO lines. Comparison between the twoGIvalus  eecuted by he Apliation software each time the gnal is used  ffApplication software behavior. This method applies to the single GPlO line used as input.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Toreduce the potential impact of common cause failure, it is recommended to use GPIO lines:.    belonging to different I/O ports (for instance port A and Bwith different bit port number (for instance PA1 and PB5)mapped to non-adjacent pins on the device packageAs GPIO pins are shared with other MCU functions, this method must not be applied to pinconnections already used by another peripheral and addressed by related safetymechanisms.</td></tr></table>

Table 47. GPIO_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>GPIO_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Loopback scheme for output GPIO lines</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method addresses GPlO lines used as outputs. Implementation is done by a loopbackscheme, connecting the output to a different GPi line programmed as input and by using theinput line to check the expected value on output port. Comparison is executed by theApplication software periodically and each time output is updated. This method applies to thesingle GPIO line used as output.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=3 colspan=1>Recommendations and known limitations</td><td rowspan=3 colspan=1>To reduce the potential impact of common cause failure, it is recommended to use GPlO lines:•    belonging to different I/O ports (for instance port A and B)with different bit port number (for instance PA1 and PB5).    mapped to non-adjacent pins on the device packageEfficiency versus transient failures is linked to final application characteristics. We define asTm the minimum duration of GPIO output wrong signal permanence required to violate therelated safety function(s). Efficiency is maximized when execution test frequency is higherthan 1/Tm.As GPIO pins are shared with other MCU functions, this method must not be applied to pinconnections already used by another peripheral and addressed by related safetymechanisms.</td></tr><tr><td rowspan=2 colspan=1>than 1/Tm.</td></tr><tr><td rowspan=1 colspan=1>: already use</td></tr></table>

# Table 48. GPIO_SM_3

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>GPIO_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>GPIO port configuration lock register</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This safety mechanism prevents configuration changes for GPlO registers; it addressesthereforeystematic faultssoftware appliationThe use of this method is encouraged to enhance the end-application robustness forsystematic faults.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>None (Systematic only)</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Applatn a usapy   cg wr qenceng e al GPIOconfiguration.</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Not required</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method does not address transient faults (soft errors) that can possibly cause bit-flips onGPIO registers at running time.</td></tr></table>

# 3.6.10 Debug system or peripheral control

# Table 49. DBG_SM_0

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DBG_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Watchdog protection</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The debugunintentional activation due  hardware random fault resultsin themassivedisturbanceU oerations, leadinganintervention hndependent watchdalternatively, the other system watchdog WwDG or the external one (CPU_SM_5).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Reset signal generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation (watchdog timeout interval).</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to CPU_SM_6.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_: Control flow monitoring in Application software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

Table 50. LOCK_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>LOCK_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Lock mechanism for configuration options</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The STM32H7 single-core series devices feature spread protection to prevent unintendedconfiguration changes for some peripherals and system registers (for example PVD_LOCK,timers); the spread protection detects systematic faults in software application. The use of thismethod is encouraged to enhance the end application robustness to systematic faults.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Not generated (when locked, register overwrites are simply ignored).</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>None (systematic only)</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Not required</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>No DC associated because this test addresses systematic faults.</td></tr></table>

# 3.6.11 System configuration controller (SYSCFG)

Table 51. SYSCFG_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SYSCFG_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to system configuration controller configuration registers.This method is strongly recommended to protect registers related to hardware diagnosticsactivation and error reporting chain related features.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method is mainly overlapped by several other configuration register read-backs requiredfor other MCU peripherals. It is reported here for the sake of completeness.</td></tr></table>

Table 52. DIAG_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DIAG_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of hardware diagnostics configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>In STM32H7 single-core series, several hardware-based safety mechanisms are available(those with the Ownership field set to ST). This method must be applied to any configurationregister related to diagnostic measure operations, including error reporting. End user musttherefordviduat niguration egisters ela•    hardware diagnostic enable•    interrupt/NMl enable (if used for diagnostic error management)</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

# 3.6.12 Direct memory access controller and direct memory access request multiplexer (DMA, MDMA, BDMA, DMAMUX)

Table 53. DMA_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DMA_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to DMA configuration register and channel address register.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 54. DMA_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DMA_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy on data packet transferred via DMA</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>p cr  Acheck (such as CRC check or similar one) with encoding capability. Full data packetredundancy would be an overkill.The checksum encoding capability must be robust enough to guarantee at least 90%probability of detection for a single bit flip in the data packet.Consistency of data packet must be checked by Application software before consuming data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>To give an example about checksum encoding capability, using just a bit-by-bit addition isinappropriate.</td></tr></table>

Table 55. DMA_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>DMA_SM_2Information redundancy by including sender or receiver identifier on data packet transferredvia DMA</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method helps to identify inside the MCU the source and the originator of the messageexchanged by DMA.Implementation is realized by adding an additional field to protected message, with a codingconvention for message type identification fixed at Device level. Guidelines for theidentification fields are:Identification field value must be different for each possible couple of sender or receiveron DMA transactions.Values chosen must be enumerated and non-trivial.Coherence between the identification field value and the message type is checked bythe Application software before consuming data.This method, when implemented in combination with DMA_SM_4, makes available a kind ofvirtual channel between source and destinations entities.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

Table 56. DMA_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DMA_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic software test for DMA</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method requires the periodical testing of the DMA basic functionality, implementedthrough a deterministic transfer of a data packet from one source to another (for example frommemory to memory) and the checking of the correct transfer of the message on the target.Data packets are comosd by non-trivial pattens (avoid theus of x00, xFFFF values)and organized in order to allow the detection during the check of the following failures:incomplete packed transfererrors in single transferred wordwrong order in packed transmitted data</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

Table 57. DMA_SM_4   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>DMA_SM_4DMA transaction awareness</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>DMA transactions are non-deterministic by nature, because typically driven by external eventslike communication messages reception. Anyway, well-designed safety systems should keepmuch control as possible of events - refer for instance to IEC 61508-3 Table 2 item 13requirements for software architecture.This method is based on system knowledge of frequency and type of expected DMAtransaction. For instance, an externally connected sensor supposed to send periodically somemessages to a STM32 peripheral. Monitoring DMA transaction by a dedicated state machineallows the detection of missing or unexpected DMA activities.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Because DMA transaction termination is often linked to an interrupt generation,implementation of this method can be merged with the safety mechanism NVIC_SM_1:Expected and unexpected interrupt check.</td></tr></table>

# 3.6.13 Chrom-Art Accelerator controller (DMA2D)

Table 58. DMA2D_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DMA2D_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Peridic readback configuration reisters</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to DMA2D configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr></table>

Table 59. DMA2D_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>DMA2D_SM_1Periodic software test for DMA2D functions</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method requires the periodical testing of the DMA2D basic functionality, implementedthrough a deterministic transfer and processing of a set of test images from memory tomemory and the checking of the correct execution (output image must be generated as perspecifications). Output image correctness can be performed by fast methods like CRCfingerprint computation.Test definition must be able to cover following DMA2D basic functions:full image copyimage filling with a speic colorcopy of part of the imagepixel format conversionblending of two different imagesAchieved diagnostic coverage on the module depends on the quantity and variance of testsperformed.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=2 colspan=1>CPU_SM_0: Periodic core self-test softwareIn principle, DMA2D basic functions not used in the safety application can be excluded fromthis test suite implementation.</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td></tr></table>

Table 60. DMA2D_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DMA2D_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>DMA processing and interrupt awareness</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is based on system knowledge of frequency and type of DMA2D transactionepeted. In general, image processing systems are based on  deterministic timing formageframing arrval and processing.Therefore, this method requires to monitor the expected execution of image processing and,in case interrupt generation is used, their correct timing and sequence.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Implementation of this method can be merged with the safety mechanism NVIC_SM_1:Expected and unexpected interrupt check</td></tr></table>

# Note:

If image processing performed by DMA2D is used for the implementation of a safety function, ystem level considerations (as consistency checks on objects recognition results) may guarantee additional diagnostic coverage.Smilary system leveldat redundancy schemes s orinstancealgorithms based on process for sequences of multiple image frames) may result in a relevant derating for transient failure rate.

# 3.6.14

# Extended interrupt and events controller (EXTI)

Table 61. NVIC_SM_0   

<table><tr><td rowspan=2 colspan=1>SM CODE</td><td></td></tr><tr><td rowspan=2 colspan=1>NVIC_SM_0Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This test is implemented by executing a periodic check of the configuration registers for asystem peripheral against its expected value. Expected values are previously stored in RAMand adequately updated after each configuration change. The method mainly addressestransient faults affecting the configuration registers, by detecting bit flips in the registerscontents. It addresses also permanent faults on registers because it is executed at least onceper PST (or another timing constraint; refer to (1) in Section 3.6 Hardware and softwarediagnostics) after an update of the peripheral.Method must be implemented to any configuration register whose contents are able tointerfere with NVIC or EXTI behavior in case of incorrect settings. Check includes NVIC vectortable.According to the state-of-the-art automotive safety standard ISO26262, this method canachieve high levels of diagnostic coverage (DC) (refer to ISO26262-5:2018, Table D.4).An alternative valid implementation requiring less space in SRAM can be realized on the basisof signature concept:Peripheral registers to be checked are read in a row, computing a CRC checksum (useof hardware CRC is encouraged).Obtained signature is compared with the golden value (computed in the same way aftereach register update, and stored in SRAM).Coherence between signatures is checked by Application software - signaturemismatch is considered as failure detection.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method addresses only failures affecting configuration registers, and not peripheral corelogic or external interface.Attention must be paid to registers containing mixed combination of configuration and statusbits. Mask must be used before saving register contents affecting signature, and relatedchecks done, to avoid false positive detections.</td></tr></table>

Table 62. NVIC_SM_1   

<table><tr><td rowspan=2 colspan=1>SM CODE</td><td></td></tr><tr><td rowspan=2 colspan=1>NVIC_SM_1Expected and unexpected interrupt check</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>According to IEC 61508-2 Table A.1 recommendations, a diagnostic measure for continuous,absence or cross-over of interrupt must be implemented. The method of expected andunexpected interrupt check is implemented at Application software level.The guidelines for the implementation of the method are the following:The interrupts implemented on the MCU are well documented, also reporting, whenpossible, the expected frequency of each request (for example, the interrupts related toADC conversion completion that come on a regular basis).Individual counters are maintained for each interrupt request served, in order to detectin a given time frame the cases of a) no interrupt at all b) too many interrupt requests.The control of the time frame duration must be regulated according to the individualinterrupt expected frequency.Interrupt vectors related to unused interrupt source point to a default handler thatreports, in case of triggering, a faulty condition (unexpected interrupt).Inc ner eviut ar beiffent rs,  playcheck on the caller identity is implemented.Important:    Interrupt requests generated by non-safety-related peripherals must behandled using the same method as all safety related interupts outlined in thelist above.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>The extension of the method to non-safety related peripherals (see last bullet in &quot;Detailedimplementation&quot; box above) is introduced to mitigate interferences between non-safety andsafety functions/hardware (FFI).</td></tr></table>

# 3.6.15 Cyclic redundancy-check calculation unit (CRC)

Table 63. CRC_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>CRC_SM_0CRC self-coverage</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The CRC algorithm implemented in this module (CRC-32 Ethernet polynomial: Ox4C11DB7)offers excellent features in terms of error detection in the message. Therefore permanent andtransient faults affecting CRC computations are easily detected by any operations using themodule to recompute an expected signature.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

# 3.6.16 CORDIC co-processor (CORDIC)

Table 64. CORD_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CORD_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to CORDIC configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 65. CORD_SM_1   

<table><tr><td colspan="1" rowspan="1">SM CODE</td><td colspan="1" rowspan="1">CORD_SM_1</td></tr><tr><td colspan="1" rowspan="1">Description</td><td colspan="1" rowspan="1">Periodic software test for CORDIC functions</td></tr><tr><td colspan="1" rowspan="1">Ownership</td><td colspan="1" rowspan="1">End user</td></tr><tr><td colspan="1" rowspan="1">SM CODE</td><td colspan="1" rowspan="2">CORD_SM_1This method requires the periodical testing of the CORDIC basic computation functionalities,implemented through a set of individual stress test. The software test must be built aroundwell-known techniques already addressed by IEC 61508-7, A.3.2 (Self-test by software:walking bit one-channel).Achivegosticoverage hemodule epens nhe quantity andvariance testsperformed.</td></tr><tr><td colspan="1" rowspan="1">Detailed implementation</td></tr><tr><td colspan="1" rowspan="1">Error reporting</td><td colspan="1" rowspan="1">Depends on implementation</td></tr><tr><td colspan="1" rowspan="1">Fault detection time</td><td colspan="1" rowspan="1">Depends on implementation</td></tr><tr><td colspan="1" rowspan="1">Addressed fault model</td><td colspan="1" rowspan="1">Permanent</td></tr><tr><td colspan="1" rowspan="1">Dependency on Device configuration</td><td colspan="1" rowspan="1">None</td></tr><tr><td colspan="1" rowspan="1">Initialization</td><td colspan="1" rowspan="1">Depends on implementation</td></tr><tr><td colspan="1" rowspan="1">Periodicity</td><td colspan="1" rowspan="1">Periodic</td></tr><tr><td colspan="1" rowspan="1">Test for the diagnostic</td><td colspan="1" rowspan="1">Not applicable</td></tr><tr><td colspan="1" rowspan="1">Multiple-fault protection</td><td colspan="1" rowspan="1">CPU_SM_0 Peridic core self-test sotwae</td></tr><tr><td colspan="1" rowspan="1">Recommendations and known limitations</td><td colspan="1" rowspan="1">None</td></tr></table>

Table 66. CORD_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>CORD_SM_2CORDIC /Arm® Cortex®-M7 periodic reciprocal comparison by software</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is based on the technique &quot;Reciprocal comparison by software&quot; (IEC 61508-7,A.3.5). The computations executed on CORDIC during Application software cycle areperiodically executed by software implementation in Arm® Cortex®-M7 CPU, and results arecompared. Being CPU integrity guaranteed by other safety mechanisms, any mismatchbetween results must be considered as a detection information for CORDIC failure(s).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>None/On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>The implementation of this method is possible only when the DTI fixed at system for periodictests level is compatible with the execution of the CORDIC computations on a slowerprocessing unit (Cortex®-M7).</td></tr></table>

Table 67. CORD_SM_3   

<table><tr><td>SM CODE</td><td>CORD_SM_3</td></tr><tr><td>Description</td><td>Double computation for CORDIC functions</td></tr><tr><td>Ownership</td><td>End user</td></tr><tr><td rowspan="2">Detailed implementation</td><td>A timing redundancy for safety-related computation performed by the CORDIC is considered to detect transient faults affecting the module itself.</td></tr><tr><td>Tqument nee pliyfey-levanputatn whic  result could interfere with the system safety functions.</td></tr><tr><td colspan="1" rowspan="1">Error reporting</td><td colspan="1" rowspan="1">Depends on implementation</td></tr><tr><td colspan="1" rowspan="1">Fault detection time</td><td colspan="1" rowspan="1">Depends on implementation</td></tr><tr><td colspan="1" rowspan="1">Addressed fault model</td><td colspan="1" rowspan="1">Transient</td></tr><tr><td colspan="1" rowspan="1">Dependency on Device configuration</td><td colspan="1" rowspan="1">None</td></tr><tr><td colspan="1" rowspan="1">Initialization</td><td colspan="1" rowspan="1">Depends on implementation</td></tr><tr><td colspan="1" rowspan="1">Periodicity</td><td colspan="1" rowspan="1">Continuous</td></tr><tr><td colspan="1" rowspan="1">Test for the diagnostic</td><td colspan="1" rowspan="1">Not applicable</td></tr><tr><td colspan="1" rowspan="1">Multiple-fault protection</td><td colspan="1" rowspan="1">CPU_SM_0: Periodic core self-test software</td></tr><tr><td colspan="1" rowspan="1">Recommendations and known limitations</td><td colspan="1" rowspan="1">None</td></tr></table>

# 3.6.17 Filter math accelerator (FMAC)

Table 68. FMAC_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FMAC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to FMAC configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controler (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 69. FMAC_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>FMAC_SM_1Periodic software test for FMAC functions</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method requires the periodical testing of the FMAC basic computation and datamnagement cionaliiplementroh  idividual res tTte must be built around well-known techniques already addressed by IEC 61508-7, A.3.2(Self-test by software: walking bit one-channel).Achieved diagnostic coverage on the module depends on the quantity and variance of testsperfformed.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

Table 70. FMAC_SM_2   

<table><tr><td rowspan=1 colspan=2>SM CODE</td><td rowspan=2 colspan=1>FMAC_SM_2FMAC/Arm Cortex-M7 periodic reciprocal comparison by software</td></tr><tr><td rowspan=1 colspan=2>Description</td></tr><tr><td rowspan=1 colspan=2>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=2>Detailed implementation</td><td rowspan=1 colspan=1>This method is based on the technique &quot;Reciprocal comparison by software&quot; (IEC 61508-7,A.3.5). The computations executed on FMAC during Application software cycle areperiodically executed by software implementation in Arm Cortex-M7 CPU, and results arecompared. Being CPU integrity guaranteed by other safety mechanisms, any mismatchbetween results must be considered as a detection information for FMAC failure(s).</td></tr><tr><td rowspan=1 colspan=2>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=2>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=2>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=2>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=2>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=2>Periodicity</td><td rowspan=1 colspan=1>Periodic/On demand</td></tr><tr><td rowspan=1 colspan=2>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=2>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=2 colspan=2>Recommendations and known limitations</td><td rowspan=2 colspan=1>The implementation of this method is possible only when the DTI fixed at system for periodictests level is compatible with the execution of the FMAC computations on a slower processingunit (Cortex-M7).</td></tr><tr><td rowspan=1 colspan=1></td></tr></table>

Table 71. FMAC_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>FMAC_SM_3Double computation for FMAC functions</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>A timing redundancy for safety-related computation performed by the FMAC is considered todetect transient faults affecting the module itself.The requirement needs be applied only to safety-relevant computation, which in case of wrongresult could interfere with the system safety functions.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

# 3.6.18 Flexible static memory controller (FSMC)

Table 72. FSMC_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>FSMC_SM_0Control flow monitoring in Application software</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>If FSMC is used to connect an external memory containing software code to be executed bythe CPU, permanent and transient faults affecting the FSMC memory controller are able tointerfere with the access operation by the CPU, leading to wrong data or instruction fetches. Astrong control fowmechanim linked to a system watchdog is able to detect such failures, incase they interfere with the expected flow of Application software.The implementation of this method is identical to the one reported for CPU_SM_1, refer therefor details.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation. Higher value is fixed by watchdog timeout interval.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>FSMC interface is available only on selected part numbers.</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This mechanism must only be used if FSMC external memory is used to store executableprograms.</td></tr></table>

Table 73. FSMC_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>FSMC_SM_1Information redundancy on external memory connected to FSMC</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>If FSMC interface is used to connect an external memory where safety-relevant data arestored, information redundancy techniques or store data are able oadress faultsaffnthe FSMC interface. The possible techniques are:using redundant copies of safety-relevant data and performing coherence check beforeconsumingorganizing data in arrays and computing the checksum field to check before use</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>FSMC interface is available only on selected part numbers.</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This mechanism must be used just if FSMC external memory is used to store safety-relateddata.This safety mechanism can overlap with information redundancy techniques implemented atsystem level to address failure of physical device connected to FSMC port.</td></tr></table>

Table 74. FSMC_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FSMC_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of FSMC configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to FSMC configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>FSMC interface is available only on selected part numbers.</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr></table>

Table 75. FSMC_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FSMC_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>ECC engine on NAND interface in FSMC module</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The FMC NAND Card controller includes two error correction code computation hardwareblocks, one per memory bank. They reduce the host CPU workload when processing the ECCby softwware.ECC mechanism protects data integrity on the external memory connected to NAND port.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to functional documentation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>ECC bits are checked during memory reading.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>FSMC interface is available only on selected part numbers.</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>FSMC_SM_2: Periodic read-back of FSMC configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method has negligible efficiency in detecting hardware random failures affecting theFSMC interface. It can be part  End user safety concept becaus adressig memorisoutside STM32H7 single-core series MCU.</td></tr></table>

# Quad-SPI / Octo-SPI interface (QUADSPI/OCTOSPI)

For this document's scope, Octo-SPI interface includes the OCTOSPIM.

Note:   
Table 76. QSPI_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>QSPI_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of QUADSPI/OCTOSPI configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to QUADSPI/OCTOSPI configuration registers.Detailed information on the implementation of this method can be found inSection 3.6. Extended interrupt and events controller XT.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 77. QSPI_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>QSPI_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Protocol error signals including hardware CRC</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>QUADSPl/OcTOSPI communication module embeds protocol error checks (like overrun,underrun, timeout and so on), conceived to detect communication-related abnormalconditions. These mechanisms are only able to detect a small fraction of hardware randomfailures affecting the module itself.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error flag raise and optional interrupt event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (for example baud rate). Refer to functionaldocumentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for CRC efficiency is not available. CRC run-time hardware failuresleading to disabling such protection fall into multiple-fault scenario, from IEC 61508perspective. Related failures are adequately mitigated by the combination of safetymechanisms reported in this table, field Multiple-fault protection.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>QSPI_SM_2: Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Enabling related interrupt generation on the detection of errors is highly recommended.</td></tr></table>

Table 78. QSPI_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>QSPI_SM_2Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is implemented adding to data packets (not commands) transferred byQUADSPI/OCTOSPI interface a redundancy check (like a CRC check, or similar one) withencoding capability. The checksum encoding capability must be robust enough to guaranteeat least 90% probability of detection for a single bit flip in the data packet.Consistency of data packet must be checked by Application software before consuming data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>To give an example on checksum encoding capability, using just a bit-by-bit addition isunappropriated.This safety mechanism can overlap with information redundancy techniques implemented atsystem level to address failure of physical device connected to QUADSPI/OCTOSPI port.</td></tr></table>

# 3.6.20 Delay block (DLYB)

Table 79. DLB_SM_0   
Note:   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DLB_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Perdic read-back of DLYB configuration regsters</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to DLYB configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.4 Extended interrupt and events controller XTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

It is assumed that DLYB output, if used, will feed STM32H7 internal communication peripherals (like, for instance QUADSPl. It is also assumed that for the connected peripherals al prescript afety mechanisms (rated as ++ and +) are correctly implemented.

# 3.6.21 Analog-to-digital converter (ADC)

Table 80. ADC_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>ADC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to the ADC configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.4 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 81. ADC_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>ADC_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Multiple acquisition by Application software</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method implements a timing information redundancy by executing multiple acquisitionson the same input signal. Multiple data acquisitions are then combined by a filter algorithm todetermine the signal correct value.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is highly probable that this recommendation is satisfied by design by the EnduserApplication software. Usage ofmultiple acquisitions followed by average operations is acommon technique in industrial applications exposed to electromagnetic interference onsensor lines.</td></tr></table>

Table 82. ADC_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>ADC_SM_2Range check by Application software</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The guidelines for the implementation of the method are the following:The expected range of the data to be acquired are investigated and adequatelydocumented. Note that in a well-designed application it is improbable that during normaloperation an input signal has a very near or over the upper and lower rail limit(saturation in signal acquisition).If the Application software is aware of the state of the system, this information is to beused in the range check implementation. For example, if the ADC value is themeasurement of a current through a power load, reading an abnormal value such as acurrent flowing in opposite direction versus the load supply may indicate a fault in theacquisition module.As the ADC module is shared between different possible external sources, thecombination of plausibility checks on the different signals acquired can help to cover thewhole input range in a very efficient way.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>The implementation and the related diagnostic efficiency of this safety mechanism are stronglyapplication-dependent.</td></tr></table>

# Table 83. ADC_SM_3

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>ADC_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic software test for ADC</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The method is implemented acquiring multiple signals and comparing the read value with theexpected one, supposed to be known. Method can be implemented with different level ofcomplexity:Basic complexity: acquisition and check of upper or lower rails (VDD or VSS) andinternal reference voltageHigh complexity: in addition to basic complexity tests, acquisition of a DAC outputconnected to ADC input and checking all voltage excursion and linearity</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Combination of two methods with different complexity can be used to better optimize testfrequency in high-demand safety functions.</td></tr></table>

# Table 84. ADC_SM_4

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>ADC_SM_4</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>1002 scheme for ADC inputs</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This safety mechanism is implemented using two different SAR ADC channels belonging toseparate ADC modules to acquire the same input signal. The Application software checks thecoherence between the two readings.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>ADC_SM_0: Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method can be used in conjunction with ADC_SM_0 / ADC_SM_2 / ADC_SM_3 toachieve highest level of ADC module diagnostic coverage.</td></tr></table>

# 3.6.22 Digital-to-analog converter (DAC)

Table 85. DAC_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DAC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to DAC configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 86. DAC_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DAC_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>DAC output loopback on ADC channel</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Roue he active DAC output o e ADCchannel,and check theutput current value againstthe expected one.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous or on demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Efficiency versus transient failures is inked tofinal application characteristics. We define asTm the minimum duration of DAC wrong signal permanence required to violate the relatedsafety function(s). Efficiency is maximized when execution test frequency is higher than 1/Tm.</td></tr></table>

# 3.6.23 Voltage reference buffer (VREFBUF)

Table 87. VREF_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>VREF_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of VREFBUF system configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to VREFBUF configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTl).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 88. VREF_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>VREF_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>VREF cross-check by ADC reading</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is based on ADC acquisition for VREF generated signal, to crosscheck with theexpected value.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Overlaps with ADC_SM_3 are possible.</td></tr></table>

# 3.6.24 Comparator (COMP)

Table 89. COMP_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>COMP_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to COMP configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTl).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 90. COMP_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>COMP_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>1002 scheme for comparator</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This safety mechanism is implemented using the two internal comparators to take the samedecision. I requires that the comparator voting is handled accordingly.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method is not compatible with window comparator feature.</td></tr></table>

Table 91. COMP_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>COMP_SM_2Plausibility check on inputs</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is used to redundantly acquire on dedicated ADC channels the analog inputs thatare subjected to comparator function, and to periodically check the coherence of thecomparator output on the measured values.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

Table 92. COMP_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>COMP_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Multiple acquisition by Application software</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method requires that Application software takes a decision not on the basis of acoparatorglehottnstion, u multleven  ter  peanecomparator trigger conditions for a certain amount of time.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is highly probable that this recommendation is satisfied by design on End user application -multiple acquisition is a common technique in industrial applications facing electromagneticinterference on sensor lines.</td></tr></table>

Table 93. COMP_SM_4   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>COMP_SM_4Comparator lock mechanism</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This safety mechanism prevents configuration changes for comparator control and statusregisters; it addresses therefore systematic faults in the software application.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>None (Fault avoidance)</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Lock protection must be enabled through the COMPxLOCK bits of the COMP_CSR register.</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method does not addresses comparator configuration changes due to soft errors.</td></tr></table>

# 3.6.25 Operational amplifiers (OPAMP)

Table 94. AMP_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>AMP_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of OPAMP configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to OPAMP configuration registers.Detailed information on themplementation f this method can e fouiSection 3.6.4 Extended interrupt and events controller (EXT).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

# Note:

Because OPAMP modules are expected to be used in signal conditioning/amplification, their use in safetyrelat fnctions leado n apliation leve scenarEnd user thereforeesponsible or themitigatin failure modes affecting the analog section of used OPAMP module(s).

# 3.6.26 Digital filter for sigma delta modulators (DFSDM)

Table 95. DFS_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DFS_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of DFSDM configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to DFSDM configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (XTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 96. DFS_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DFS_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Multiple acquisition by Application software</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method implements a timing information redundancy by executing multiple acquisitions sampu sal Multipl acusitn dat eheb y fralgo determine the signal correct value.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is highly probable that this recommendation is satisfied by design by End userApplicationsoftware. Usage of multiple acquisitions followed by average operations is a commontechnique in industrial applications where it is needed to survive with spurious EMI disturbs onsensor lines.</td></tr></table>

Table 97. DFS_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DFS_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Range check by Application software</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is implemented as described in ADC_SM_2: Range check by Applicationsoftware.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>The implementation of this safety mechanism is strongly application-dependent.</td></tr></table>

Table 98. DFS_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DFS_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>1002 scheme for DFSM inputs</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This safety mechanism is implemented using two different DFSM modules to acquire thesame input signal. The Application software checks the coherence between the two readings.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>DFS_SM_0: Periodic read-back of DFSDM configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method can be used in conjunction with DFS_SM_0 to achieve highest level of DFSMmodule diagnostic coverage (as an alternative to DFS_SM_1 and DFS_SM_2).</td></tr></table>

# 3.6.27 Digital camera interface (DCMI)

# Table 99. DCMI_SM_0

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DCMI_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of DCMI configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to DCMI configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>DCMI interface is available only on selected part numbers.</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 100. DCMI_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DCMI_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>DCMI video input data synchronization</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>According to the nature of video data stream received, DCMl module implementssynchronization controls, from the simplest one (hardware synchronization) to the mostcomplex (e.g. embedded data synchronization mode). DCMi internal failures leading to theincapability of correcting synchronizing the data stream can be therefore detected.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>No explicit error signal/message generation is provided (*).</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>DCMI interface is available only on selected part numbers.</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>DCMI_SM_0: Periodic read-back of DCMI configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>(*) For its nature, the detection of an actual hardware failure by this safety mechanism can beconfused with functional-related scenarios (e.g. camera device disconnected or powered-off).It is responsibility of Application software to discriminate, as far as it is technically possible,among different events.</td></tr></table>

# 3.6.28 LCD-TFT display controller (LTDC)

# Table 101. LCD_SM_0

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>LCD_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of LTDC configuration registers and buffer memory</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to LTDC configuration registers and to the buffer memory.Detailed information on the implementation of this method can be found inSecion 3.6.4 Extended interrupt and events controller EXT).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 102. LCD_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>LCD_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>LTDC acquisition by ADC channel</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Correct generation of LTDC driving signals is checked by ADC reading versus expectedvalues</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method is conceived to mainly detect permanent failures affecting analog parts andtherefore the execution on periodic way is acceptable. Diagnostic coverage achievabledepends on the quantity of LTDC signals checked</td></tr></table>

# Note:

The above-described safety mechanism addresses the LTDC interface included in STM32 MCUs. Because actal capability correc mage eneration n LTDCis ot adresed bythis safeymechanism, in cas such far  onsier afety elevannus warned  evaluat hedoptindequatystevel measures.

# 3.6.29 JPEG codec (JPEG)

# Table 103. JPEG_SM_0

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>JPEG_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of JPEG codec configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to JPEG codec configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple faults protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 104. JPEG_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>JPEG_SM_1Periodic test for JPEG encoding/decoding functions</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>JPEG encoding/decoding functions performed by JPEG codec are tested by comparison,executing the functions over a set of reference images stored in the flash memory andchecking the correctness of output images. The method diagnostic coverage depends on thequantity and composition of image set used for the checks.The comparison of output image with expected result can be executed bit-by-bit or even byfaster methods like CRC-seed (computed via DMA transactions) checks.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>If only one kind of function between encoding and decoding is used by Application software,the method can be simplified restricting the test to the used function only.</td></tr></table>

Table 105. JPEG_SM_2   
Note:   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>JPEG_SM_2Atn-</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Several application-level methods can be used to detect failures affecting JPEG coding/encoding; being no possible to give detailed information for its implementation, only high levelguidelines/hints are provided:Permanent and transient failures: Application software checks on expected outputimage characteristics (for example, after the processing by image recognitionalgorithms)Transient faults: Application software checks on images redundancy (in case ofsequence coming from video stream) possibly discarding wrongly-processed frames.This rationale could be also used to derate a part of transient failure rate as no effect.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic/On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>related claims in terms of failure mitigations are End user&#x27;s responsibility.</td></tr></table>

T eA tnsehdl quheoptneeanif the system DMA (refer to Section 3.6.12 Direct memory access controller and direct memory access request multiplexer (DMA, MDMA, BDMA, DMAMUX)).

# 3.6.30 HASH processor (HASH)

Table 106. HASH_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>HASH_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of HASH configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to HASH configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTIl).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>HASH module available only on specific part numbers</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 107. HASH_SM_1   
Note:   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>HASH_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>HASH processing collateral detection</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Message digest computation performed by HASH module is composed by several datamanipulations and checks. A major part of the hardware random failures affecting HASHmodule leads to algorithm violations/errors, and so to decoding errors on the receiver side.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Several error condition can happens, check functional documentation.</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>HASH module available only on specific part numbers</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for HASH efficiency is not available. HASH run-time hardware failuresleading to disabling related collateral protection fall into multiple-fault scenario, fromIEC 61508 perspective. Related failures are adequately mitigated by the combination of safetymechanisms reported in this table, field Multiple-fault protection.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>HASH_SM_0: Periodic read-back of HASH configuration registersCPU_SM_0: Periodic coreself-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This detection capability can be used to implement software-based tests (by processing apredefined message and further checking the expected results) which can be executedperiodically to early detect HASH failures before ts use by application software.</td></tr></table>

Hardware random failures consequences on potential security features violations are not analyzed in this manual.

# 3.6.31 On-the-fly decryption engine (OTFDEC)

# Table 108. OTFDEC_SM_0

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>OTFDEC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodical read-back of OTFDEC configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to OTFDEC configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.4 Extended interrupt and events controller EXT.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr></table>

Table 109. OTFDEC_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>OTFDEC_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>OTFDEC encryption/decryption collateral detection</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Decryption operations performed by OTFDEC module are composed by several datamanipulations and checks, with dfferent level of complexity according to the selected chainingalgorithm. Part of the hardware random failures affecting OTFDEC module leads to the raiseof error flags.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Several error conditions can happen, check functional documentation.</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration. Refer to functional documentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Dependency on Device configuration</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>OTFDEC_SM_2: Arm® Cortex®-M33 HardFault exceptionsOTFDEC_SM_3: Static data encapsulation</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

# Table 110. OTFDEC_SM_2

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>OTFDEC_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Arm® Cortex®-M7 HardFault exceptions</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Permanent and transient faults affecting the OTFDEC logic and registers may lead toapplication software or firmware decryption errors and so to the execution of incorrectinstruction codes, and eventually to the intervention of the Arm® Cortex®-M33 HardFaultexceptions. Refer to CPU_SM_3 for detailed description.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to CPU_SM_3</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method is efficient only when OTFDEC is used for executable code decryption</td></tr></table>

Table 111. OTFDEC_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>OTFDEC_SM_3Static data encapsulation</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>If static data stored in flash memory need to be decrypted by OTFDEC, then an encapsulationby a checksum field with encoding capability (such as CRC) must be implemented. Checksum</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method is fficient only when OTFDEC is used for data decryption</td></tr></table>

# 3.6.32 True random number generator (RNG)

Table 112. RNG_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>RNG_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of RNG configuration register</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to RNG configuration register RNG_CR.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>RNG module available only on specific part numbers</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 113. RNG_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>RNG_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>RNG module entropy on-line tests</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST and End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>RNG module include an internal diagnostic for the analog source entropy that can be used todetect failures on the module itself. Furthermore, the required test on generated randomnumber difference between the previous one (as required by FIPS PUB 40-2) can beexploited as well.Implementation:Check for RNG error conditions.•    Check the difference between generated random number and the previous one.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>CEIS, SEIS error bits of the RNG status register (RNG_SR)Application software error for FIPS PUB 140-2 test fail</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>RNG module available only on specific part numbers</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

# 3.6.33 Cryptographic processor (CRYP)

Table 114. CRYP_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CRYP_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of CRYP configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to CRYP configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>CRYP module available only on specific part numbers</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 115. CRYP_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CRYP_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Encryption/decryption collateral detection</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Encryption and decryption operations performed by CRYP module are composed by severaldata manipulations and checks, with different level of complexity according to the selectedchaining algorithm. A major part of the hardware random failures affecting CRYP moduleleads to algorithm violations/errors. Leading to decoding errors on the receiver side.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Several error conditions can happen, check functional documentation.</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Dependency on Device configuration</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>CRYP module available only on specific part numbers</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Dependency on Device configuration</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for CRYP efficiency is not available. CRYP run-time hardware failuresleading to disabling such protection fall into multiple-fault scenario, from IEC 61508perspective. Related failures are adequately mitigated by the combination of safetymechanisms reported in this table, field Multiple-fault protection.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CRYP_SM_2: Information redundancy techniques on messages, including end-to-endprotection</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

Table 116. CRYP_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CRYP_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques onmessages, including end-o-end protection</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method aim to protect the communication between a peripheral and his externalcounterpart. It is used in CRYP local safety concept to address failures not detected by theencryption/decryption features.Refer to UART_SM_3 description for detailed information.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>CRYP module available only on specific part numbers</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Irtant note t is assumed that the remote counterpart has an equivalent capability performing the checks described.Refer to UART_SM_3 for further notice.</td></tr></table>

# Important:

Harwan iuencpotentvtisDcuriatuo et manual.

# 3.6.34

# Advanced-control/General-purpose/High resolution and low-power timers

As thetimers havemultiplemutually independent hannes possiblyusedordifferent functions, thesfey mechanism is selected individually for each channel.

Table 117. ATIM_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>ATIM_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back f configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to advanced, general-purpose and low-power timer configurationregisters.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 118. ATIM_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=3 colspan=1>ATIM_SM_11002 for counting timersEnd user</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method implements via software a 1oo2 scheme between two counting resources.The guidelines for the implementation of the method are the following:Two timers are programmed with same time base or frequency.In case of timer use as a time base: use in Application software one of the timer as timebase source, and the other one just for check. Coherence check for the 1oo2 is done atapplication level, comparing two counter values each time the timer value is used toaffect safety function.In case of interrupt generation: use the first timer as main interrupt source for theservice routines, and the second timer as a &quot;reference&quot; to be checked at the initial ofinterrupt routine.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Tolerance implementation in timer checks is recommended to avoid false positive outcomes ofthe diagnostic.This method applies to timer channels merely used as elapsed time counters.Events related to timers protected by the safety mechanisms must be monitored inside theroutine managing the external watchdog (CPU_SM_5) reset.Note:         One timer may act as a reference for multiple other timers.</td></tr></table>

Table 119. ATIM_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>ATIM_SM_2102 for input capture timers</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is conceived to protect timers used for acquisition and measurement of externalsignals (input capture, encoder reading). The implementation consists in connecting theexternal signals also to a redundant timer, and checking the coherence of the measured dataat application level.Coherence check between timers is executed each time the reading is used by Applicationsoftware.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>To reduce the potential effect of common cause failures, it is suggested to use for redundantcheck a channel belonging to a different timer module and mapped to non-adjacent pinn thedevice package.</td></tr></table>

Table 120. ATIM_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>ATIM_SM_3Loopback scheme for pulse width modulation (PWM) outputs</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is implemented by connecting the PWM to a separate timer channel to acquirethe generated waveform characteristics.The guidelines are the following:Both PWM frequency and duty cycle are measured and checked versus the expectedvalue.To reduce the potential effect of common cause failure, it is suggested to use for theloopback check a channel belonging to a different timer module and mapped to non-adjacent pins on the device package.Thismeasure can be replaced under the ed-user respnsibility by iffrent looacschemes already in place in the final application and rated as equivalent. For example if thePWM is used to drive an external power load, the reading of the on-line current value can beused instead of the PWM duty cycle measurement.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Efficiency versus transient failures is linked to final application characteristics. We define asTm the minimum duration of PWM wrong signal permanence (wrong frequency, wrong duty, orbot required to violate the relate safetyunction() Efficiency ismaxmized when exeutintest frequency is higher than 1/Tm.</td></tr></table>

Table 121. ATIM_SM_4   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>ATIM_SM_4</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Lock bit protection for timers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This safety mechanism allows End user to lock down specified configuration options, thusavoidingunintendedmodifications bApplication software.Therefore addresses sotdevelopment systematic faults.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>None (Fault avoidance)</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Lock protection must be enabled using LOCK bits in the TIMx_BDTR register.</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method does not address timer configuration changes due to soft errors.</td></tr></table>

IRTIM is not individually mentioned here as its implementation is mostly based on general-purpose timer functions. Refer to related prescriptions.

# 3.6.35 Basic timers

Table 122. GTIM_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>GTIM_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Peridi read-backnfiguration egsters</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to basic timer configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 123. GTIM_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=3 colspan=1>GTIM_SM_11002 for counting timersEnd user</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method implements via software a 1oo2 scheme between two counting resources.The guidelines for the implementation of the method are the following:Two timers are programmed with same time base or frequency.In case of timer use as a time base: use in Application software one of the timer as timebase source, and the other one just for check. Coherence check for the 1oo2 is done atapplication level, comparing two counters values each time the timer value is used toaffect safety function.In case of interrupt generation usage: use the first timer as main interrupt source for theservice routines, and use the second timer as a &quot;reference&quot; to be checked at the initialof interrupt routine.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Tolerance implementation in timer checks is recommended to avoid false positive outcomes ofthe diagnostic.Events related to timers protected by the safety mechanisms must be monitored inside theroutine managing the external watchdog reset.Note:        One timer may act as a reference for multiple other timers.</td></tr></table>

# 3.6.36 Independent and system window watchdogs (IWDG and WWDG)

Table 124. WDG_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>WDG_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to IWDG/WWDG configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTl).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 125. WDG_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>WDG_SM_1Software test for watchdog at startup</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This safety mechanism ensures the right functionality of the internal watchdogs in use. Thetest implementation allows the application software to induce a watchdog reset for a specificpurpose such as at startup, and to determine that the cause of the reset was the testprocedure itself, and not a software/hardware malfunction. This is confirmed by reading theassociated hardware flag in the RCC status register before and after the test and applyingspecific SW flag, which stores nontrivial pattern at SRAM, just during the test execution. Boththe HW and SW flags must be cleared once the test is done. This is essential to avoidrepeating the test in a loop, and to correctly manage watchdog resets related to failures.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Startup</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>In a typical nd useappliation, his test can eexecute only at startup anumaintenance or offline periods. It could be associated to IEC 61508 concept of &quot;proof test&quot; andso it cannot be accounted for a diagnostic coverage contribution during operating time.</td></tr></table>

# 3.6.37 Real-time clock module (RTC)

# Table 126. RTC_SM_0

Table 127. RTC_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>RTC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to RTC configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>RTC_SM_1Application check of running RTC</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The Application software implements some plausibility check on RTC calendar ortimingdata,mainly after a power-up and further date reading by RTC.The guidelines or theimplementation  themethod are the following:RTC backup registers are used to store coded information in order to detect theabsence of VBAT during power-off period.RTC backup registers are used to periodically store compressed information on currentdate or timeThe Application software executes minimal consistence checks for date reading afterpower-on (detecting &quot;past&quot; date or time retrieve).The Application software periodically checks that RTC is actually running, by readingRTC timestamp progress and comparing with an elapsed time measurement based onSTM32 internal clock or timers.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method provides a limited diagnostic coverage for RTC failure modes. In case of Enduser application where RTC timestamps accuracy can affect in severe way the safety function(for example, medical data storage devices), it is strongly recommended to adopt moreefficient system-level measures.</td></tr></table>

Table 128. RTC_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>RTC_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy on backup registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Data stored in RTC backup registers must be protected by a checksum with encodingcapability or instance, CRC).Checksum must be checked by application software borconsuming stored data.This method guarantees data versus erases due to backup battery failures.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic/On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

# Table 129. RTC_SM_3

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>RTC_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Application-level measures to detect failures in timestamps/event capture</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must detect failures affecting the RTC capability to correct execute thetimestamps/event capture functions. Due to the nature strictly application-dependent of thissolution, no detailed guidelines for its implementation are given here.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic/On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method must be used only if the timestamps/event capture function is used in the safetyfuionplentatio wor otn hae etamv ptu y-related applications with the MCU in Sleep or Stop mode is prevented by the assumedrequirement ASR7 (refer to Section 3.3.1 Safety requirement assumptions).</td></tr></table>

# 3.6.38 Tamper and backup registers (TAMP)

Table 130. TAMP_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>TAMP_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy on tamper backup registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Data stored in tamper backup registers must be protected by a checksum with encodingcapability or instance, CRC). Checksum must be checked by Application software beoreconsuming stored data.This method guarantees data versus erases due to backup battery failures.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

# 3.6.39 Inter-integrated circuit (I2C)

Table 131. IIC_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>IIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to I2C configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 132. IIC_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>IIC_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Protocol error signals</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>I2C communication module embeds protocol error checks (like overrun, underrun, packeterror etc.) conceived to detect network-related abnormal conditions. These mechanisms areonly able to detect a small fraction of hardware random failures affecting the module itself.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error flag raise and optional interrupt event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (for example baud rate). Refer to functionaldocumentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>IIC_SM_2: Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Adoption of SMBus option grants the activation of more efficient protocol-level hardwarechecks such as CRC-8 packet protection.Enabling related interrupt generation on the detection of errors is highly recommended.</td></tr></table>

Table 133. IIC_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>IIC_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is implemented adding to data packets transferred by I2C a redundancy check(such as a CRC check, or similar one) with encoding capability. The checksum encodingcapability must be robust enough to guarantee at least 90% probability of detection for asingle bit flip in the data packet.Consistency of data packet must be checked by Application software before consuming data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is assumed that the remote I2C counterpart has an equivalent capability of performing thecheck described.To give an example on checksum encoding capabiliy, using just a bit-by-bit addition isunappropriated.Important:    This method must be considered as a subset of lIC_SM_4. Therefore, theimplementation of lIC_SM_4 completely overlap this method. Refer to [4] foradditional details.</td></tr></table>

Table 134. IIC_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>IIC_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>CRC packet-level</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>IC communication module allows to activate for specific mode of operation (SMBus) theautomatic insertion (and check) of CRC checksums to packet data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error fag raise and optional Interrupt Event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for CRC efficiency is not available. CRC run-time hardware failuresleading to disabling such protection fall into multiple-fault scenario, from IEC 61508perspective. Related failures are adequately mitigated by the combination of safetymechanisms reported in this table, field Multiple-fault protection.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>IIC_SM_2: Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method can be part of the implementation for IIC_SM_2 or lIC_SM_4. In that case,because of the warning issued in the Test for the diagnostic field, this mechanism can not bethe only one to guarantee message integrity.Enabling related interrupt generation on the detection of errors is highly recommended.</td></tr></table>

Table 135. IIC_SM_4   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>∥IC_SM_4</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques on messages, including end-to-end protection</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method aims to protect the communication between a I2C peripheral and his externalcounterpart.Refer to UART_SM_3 description for detailed information.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to UART_ SM_3</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is assumed that the remote I2C counterpart has an equivalent capability of performing thechecks described.Refer to UART_SM_3 for further notice.</td></tr></table>

# 3.6.40 Universal synchronous/asynchronous receiver/transmitter and low power universal asynchronous receiver/transmitter (USART, UART, LPUART)

Table 136. UART_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>UART_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to USART, UART, LPUART configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 137. UART_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>UART_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Protocol error signals</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>USART, UART, LPUART communication module embeds protocol error checks (like additionalparity bit check, overrun, frame error) conceived to detect network-related abnormalconditions. These mechanisms are only able to detect a small fraction of hardware randomfailures affecting the module itself.Error signals connected to these checkers are normally handled in a standard communicationsoftware, so the overhead is reduced.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error flag raise and optional interrupt event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (for example baud rate). Refer to functionaldocumentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>UART_SM_2: Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>USART, UART, LPUART communication module allows several different configurations. Theactual composition of communication error checks depends on the selected configuration.Enabling related interrupt generation on the detection of errors is highly recommended.</td></tr></table>

Table 138. UART_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>UART_SM_2Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is implemented by adding to data packets transferred by this peripheral aredundancy check (such as a CRC check, or similar one) with encoding capability. Thechecksum encoding capability must be robust enough to guarantee at least 90% probability ofdetection for a single bit flip in the data packet.Consistency of data packet must be checked by Application software before consuming data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is assumed that the remote counterpart has an equivalent capability of performing the checkdescribed.To give an example on checksum encoding capability, using just a bit-by-bit addition isunappropriated.Important:    This method must be considered as a subset of UART_SM_3. Therefore,the implementation of UART_SM_3 completely overlap this method. Refer to[4] for additional details.</td></tr></table>

Table 139. UART_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>UART_SM_3Information redundancy techniques on messages, including end-to-end protection</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method aims to protect the communication between a peripheral and his externalcounterpart establishing a kind of &quot;protected&quot; channel. The aim is to specifically addresscommunication failure modes as reported in IEC 61508-2, 7.4.11.1.Implementation guidelines are as follows:Data packet must be protected (encapsulated) by an information redundancy check,like for instance a CRC checksum computed over the packet and added to payload.Checksum encoding capability must be robust enough to guarantee at least 90%probability of detection for a single-bit flip in the data packet.Additional field added in payload reporting an unique identification of sender or receiverand an unique increasing sequence packet number.Timing monitoring of the message exchange (for example check the message arrivalwithin the expected time window), detecting therefore missed message arrivalconditions.Application software must verify before consuming data packet its consistency (CRCcheck), its legitimacy (sender or receiver) and the sequence correctness (sequencenumber check, no packets lost).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>A major overlap between the requirements of this method and the implementation of complexcommunication software protocols can exists. Due to large adoption of these protocols inindustrial applications, optimizations can be possible.It is assumed that the remote counterpart has an equivalent capability of performing thechecks described.</td></tr></table>

# 3.6.41 Serial peripheral interface (SPl)

Table 140. SPI_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>SPI_SM_0Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to SPI configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 141. SPI_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SPI_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Protocol error signals</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>SPI communication module embeds protocol error checks (ike overrun, underrun, timeoutand so on) conceived to detect network-related abnormal conditions. These mechanisms areonly able to detect a small fraction of hardware random failures affecting the module itself.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error flag raise and optional interrupt event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (or example baud rate). Refer to functionaldocumentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>SPI_SM_2: Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

Table 142. SPI_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SPI_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is implemented adding to data packets transferred by SPI a redundancy check(such as a CRC check, or similar one) with encoding capability. The checksum encodingcapability must be robust enough to guarantee at least 90% probability of detection for asingle bit flip in the data packet.Consistency of data packet must be checked by Application software before consuming data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is assumed that the remote counterpart has an equivalent capability of perorming the checkdescribed.To give an example on checksum encoding capability, using just a bit-by-bit addition isunappropriated.Important:    This method must be considered as a subset of SPI_SM_4. Therefore, theimplementation of SPI_SM_4 completely overlap this method. Refer to [4]for additional details.</td></tr></table>

Table 143. SPI_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SPI_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>CRC packet-level</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>SPI communication module allows to activate automatic insertion (and check) of CRC-8 orCRC-18 checksums to packet data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error flag raise and optional Interrupt Event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (for example baud rate). Refer to functionaldocumentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for CRC efficiency is not available. CRC run-time hardware failuresleading to disabling such protection fall into multiple-fault scenario, from IEC 61508perspective. Related failures are adequately mitigated by the combination of safetymechanisms reported in this table, field Multiple-fault protection.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>SPI_SM_2: Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method can be part of the implementation for SPI_SM_2 or SPI_SM_4. In that case,because of the warning issued in the Test for the diagnostic field, this mechanism can not bethe only one to guarantee message integrity.</td></tr></table>

Table 144. SPI_SM_4   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SPI_SM_4</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques on messages, including end-to-end protection</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method aims to protect the communication between SPI peripheral and his externalcounterpart.Refer to UART_SM_3 description for detailed information.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to UART_SM_3 for further notice.It i assmed that the remote SP counterpart has an equivalent capability of performing hechecks described.</td></tr></table>

# 3.6.42 Serial audio interface (SAI)

Table 145. SAI_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SAI_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of SAl configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to SAl configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.4 Extended interrupt and events controller (XT.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 146. SAI_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>SAI_SM_1SAI output loopback scheme</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method uses a loopback scheme to detect permanent and transient faults on the outputchannel used for serial audio frame generation. It is implemented by connecting the secondserial audio interface as input for primary output generation. Application software is abletheroentrnssgu</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous/ On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>EfllathaWTm the minimum duration of serial audio wrong signal permanence required to violate therelated safety function(s). Efficiency is maximized when execution test frequency is higherthan 1/Tm.Method to be used when SAl interface safety-related use is audio stream generation.</td></tr></table>

Table 147. SAI_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SAI_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>1002 scheme for SAl module</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This safety mechanism is implemented using the two SAl interfaces to decode/receive thesame input stream audio. Application software checks the coherence between the receiveddata.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>The MCU performance overload and the implementation complexity associated to this methodcan be relevant.Method to be used when SAl interface safety-related use is audio stream receive.</td></tr></table>

# 3.6.43 SPDIF receiver interface (SPDIFRX)

Table 148. SPDF_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SPDF_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of SPDIF configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to SPDIF configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 149. SPDF_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SPDF_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Protocol error signals</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>IEC60598 S/PDIF data frame specification used in SPDIF interface embeds protocol errorchecks (like overrun, underrun, bit timing violations, parity, etc.) conceived to detecttransmission-related abnormal conditions. These mechanisms are able anyway to detect amarginal percentage of hardware random failures affecting the module itself.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error flag raise and optional Interrupt Event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>SPDF_SM_0: Periodic read-back of SPDIF configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Enabling related interrupt generation on the detection of errors s highly recommended.</td></tr></table>

Table 150. SPDF_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SPDF_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is implemented adding to data S/PDIF data stream some form of informationredundancy, possibly including information repetition, to address failure modes affecting thedecoding section of the module.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method could be replaced by application-level alternative measures checking thecorrectness f the audio stream received. One given example could be represented by a seof plausibility checks executed after post-elaboration by voice recognition algorithms.</td></tr></table>

# 3.6.44 Single Wire Protocol Master Interface (SWPMI)

Table 151. SWPMI_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SWPMI_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to SWPMI configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 152. SWPMI_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SWPM_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Protocol error signals and information redundancy including hardware CRC</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>SWPMI communication is based on a frame handling concept, composed by a combination ofhardware synchronization signals, frame structure composition, hardware-computed CRCfiled. This mechanism, mainly implemented to manage on-field communication disturbance, isable to achieve a relevant diagnostic coverage on several SwMPl module failure modes.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error conditions are reported by flag bits in related registers.</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for CRC efficiency is not available. CRC run-time hardware failuresleading to disabling such protection fall into multiple-fault scenario, from IEC 61508perspective. Related failures are adequately mitigated by the combination of safetymechanisms reported in this table, field Multiple-fault protection.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>SWPMI_SM_0: Periodic read-back of configuration registersSWPMI_SM_2: SWMPI loopback test</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method is unable to address all IEC 61508 failure modes related to time handshakebetween parties (e.g. resequencing, repetition), leading to the introduction of SWPMI_SM_3.Enabling related interrupt generation on the detection of errors is highly recommended.</td></tr></table>

Table 153. SWPMI_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SWPMI_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>SWMPI loopback test</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>By using the SWPMI module loopback function, it is possible to emulate the sending of SWPIframes and cross-checking the expected result in reception.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error conditions are reported by flag bits in related registers</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Loopback mode must be enabled.</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>SWPMI_SM_0: Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td></td></tr></table>

Table 154. SWPMI_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>SWPMI_SM_3Information redundancy techniques on messages to implement ful end-to-end operation</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method aims to protect the communication between a peripheral and its externalcounterpart establishing a kind of &quot;protected&quot; channel. The aim is to specifically addresscommunication failure modes as reported in IEC 61508-2, 7.4.11.1.Implementation guidelines are the following:Additional field added in payload reporting an unique identification of sender/receiverand an unique increasing sequence packet numberTiming monitoring of the message exchange (for example check the message arrivalwithin the expected time window), detecting therefore missed message arrivalconditionsApplication software must verify before consuming data packet its consistency (CRCcheck), its legitimacy (sender/receiver) and the correctness of sequence (sequencenumber check, no packets lost)</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is assumed that the remote SwMPI counterpart has an equivalent capability of performingthe checks described. This method is simplified by the existence of SWPMI_SM_1.A major overlap between the requirements of this method and the implementation of securityprotection on the transaction is possible.</td></tr></table>

# 3.6.45 Management data input/output (MDIOS)

# Table 155. MDIO_SM_0

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>MDIO_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of MDIO slave configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to MDIO slave configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 156. MDIO_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>MDIO_SM_1Protocol error signals</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>MDIO communication protocol is based on a packet handling concept, including preamble/start/stop correct conditions checks. This mechanism, mainly implemented to manage on fieldcommunication disturbance, is able to achieve a relevant diagnostic coverage on severalMDIO module failure modes.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error conditions are reported by flag bits in related registers, and interrupt generation.</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>DSI_SM_0: Periodic read-back of DSI configuration registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Not applicable</td></tr></table>

Table 157. MDIO_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>MDIO_SM_2Information redundancy techniques on MDIO registers contents, including register updateawareness</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Information provided by external parties by MDIO communication must be protected byredundancy schemes (encoded data values and possibly the definition of a checksumregister).Application software must be aware of any register value update executed by external parties,so it is needed the implementation of a validate/invalidate mechanism to:report to external party that updated data have been consumedmark as invalidated any data already consumed.    allow external party to inform Application software that new data are available</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not required</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is assumed that he external entity responsible to update/send data to Application soa atn uiadetecting missing or incomplete data consumption.</td></tr></table>

# 3.6.46 Secure digital input/output MultiMediaCard interface (SDMMC)

Table 158. SDIO_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SDIO_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of SDIO/SMMC configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to SDIO/SMMC configuration registers.Detailed information on the implementation of this method can be found inSection 3.6. Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 159. SDIO_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SDIO_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Protocol error signals including hardware CRC</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>SDIO/sMMC communication module embeds protocol error checks (like overrun, underrun,timeout etc.) and CRC-packet checks as well, conceived to detect network-related abnormalconditions. These mechanisms are only able to detect a small fraction of hardware randomfailures affecting the module itself.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error ag i n otial nterrupteven gnaion</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (for example baud rate). Refer to functionaldocumentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>SDIO_SM_2: Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Enabling related interrupt generation onhe detection  errors ishighly recommended.</td></tr></table>

Table 160. SDIO_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>SDIO_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method s implemente adding  data packets transferred by SDIO/SMM a redundancycheck (like a CRC check, or similar one) with encoding capability. The checksum encodingcapability must be robust enough to guarantee at least 90% probability of detection for asingle bit flip in the data packet.Consistency of data packet must be checked by Application software before consuming data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>To give an example on checksum encoding capability, using just a bit-by-bit addition isunappropriated.This safety mechanism can overlap with information redundancy techniques implemented atsystem level to address failure of physical device connected to SDIO/SMMMC port.</td></tr></table>

# Note:

The safety mechanisms mentioned above are addressing the SDIO/SMMC interface included in STM32 MCUS. Noclaims aredonen thisSafety Manual about themitgationhardwareandom faults affecting theexteal memory connected to SDIO/SMMC port.

# 3.6.47 Controller area network (FDCAN)

# Table 161. CAN_SM_0

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>CAN_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to FDCAN configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 162. CAN_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>CAN_SM_1Protocol error signals</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>CAN communication module embeds protocol error checks (like error counters) conceived todetect network-related abnormal conditions. These mechanisms are only able to detect asmall fraction of hardware random failures affecting the module itself.Error signals connected to these checkers are normally handled in a standard communicationsoftware, so the overhead is reduced.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Several error condition are reported by flag bits in related CAN registers.</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (for example baud rate). Refer to functionaldocumentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CANSM_2: Information redundancy techniques on messages, including end-to-endprotection.</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Enabling related interrupt generation on the detection of errors is highly recommended.</td></tr></table>

Table 163. CAN_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>CAN_SM_2Information redundancy techniques on messages, including end-to-end protection.</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method aims to protect the communication between a peripheral and his externalcounterpart establishing a kind of &quot;protected&quot; channel. The aim is to specifically addresscommunication failure modes as reported in IEC 61508-2, 7.4.11.1.Implementation guidelines are as follows:Data packet must be protected (encapsulated) by an information redundancy check,like for instance a CRC checksum computed over the packet and added to payload.Checksum encoding capability must be robust enough to guarantee at least 90%probability of detection for a single-bit flip in the data packet.Additional field added in payload reporting an unique identification of sender or receiverand an unique increasing sequence packet number.Timing monitoring of the message exchange (for example check the message arrivalwithin the expected time window), detecting therefore missed message arrivalconditions.Application software must verify before consuming data packet its consistency (CRCcheck), its legitimacy (sender or receiver) and the sequence correctness (sequencenumber check, no packets lost).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>A major overlap between the requirements of this method and the implementation of complexcommunication software protocols can exists. Due to large adoption of these protocols inindustrial applications, optimizations can be possible.It is assumed that the remote counterpart has an equivalent capability of performing thechecks described.</td></tr></table>

# 3.6.48 USB on-the-go high-speed (OTG_HS)

Table 164. USB_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>USB_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to USB configuration registers.Detailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 165. USB_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>USB_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Protocol error signals</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>USB communication module embeds protocol error checks (like overrun, underrun, NRZl, bitstuffing etc.) conceived to detect network-related abnormal conditions. These mechanisms areonly able to detect a small fraction of hardware random failures affecting the module itself.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error flag raise and optional interrupt event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (for example baud rate). Refer to functionaldocumentation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>USB_SM_2: Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Enabling related interrupt generation on the detection of errors is highly recommended.</td></tr></table>

Table 166. USB_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>USB_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user or ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>The implementation of required information redundancy on messages, USB communicationmodule is fitted by hardware capability. It basically allows to activate the automatic insertion(and check) of CRC checksums to packet data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error flag raise and optional interrupt event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (for example baud rate). Refer to functionaldocumentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Er eorti configuration  interrutevent  lnd</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Important:    This method must be considered as a subset of USB_SM_3. Therefore, theimplementation of USB_SM_3 completely overlap this method. Refer to [4]for additional details.</td></tr></table>

Table 167. USB_SM_3   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>USB_SM_3</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques on messages, including end-to-end protection.</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method aims to protect the communication between the OTG_HS peripheral and itsexternal counterpart.Refer to UART_SM_3 description for detailed information.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to UART_SM_3</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>This method applies in case USB bulk or isochronous transfers are used. For other transfersmodes the USB hardware protocol already implements several features of this requirement.Refer to UART_SM_3 for further notice.</td></tr></table>

# 3.6.49 Ethernet (ETH): media access control (MAC) with DMA controller

Table 168. ETH_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>ETH_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of Ethernet configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to Ethernet configuration registers (including those relate tounused module features). Detailed information on the implementation of this method can befound in Section 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 169. ETH_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>ETH_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Protocol error signals including hardware CRC</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Ethernet communication module embeds protocol error checks (like overrun, underrun,timeout, packet composition violation etc.) and CRC-packet checks as well, conceived todetect network-related abnormal conditions. These mechanisms are able anyway to detect apercentage of hardware random failures affecting the module itself.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error flag raise and optional Interrupt Event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (for example baud rate). Refer to functionaldocumentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Direct test procedure for CRC efficiency is not available. CRC run-time hardware failuresleading to disabling such protection fall into multiple-fault scenario, from IEC 61508perspective. Related failures are adequately mitigated by the combination of safetymechanisms reported in this table, field Multiple-fault protection.</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>ETH_SM_2: Information redundancy techniques on messages, including end-to-endprotection</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Enabling related interrupt generation on the detection of errors is highly recommended.</td></tr></table>

Table 170. ETH_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>ETH_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques onmessages, including end-to-end protection</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method aim to protect the communication between a peripheral and its externalcounterpart. It is used in Ethernet local safety concept to address failures not detected byETH_sM_1 and to increase its associated diagnostic coverage.Refer to UART_SM_3 description for detailed information.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>The implementation on Application software of complex Ethernet-based communicationstacks (like TCP/IP) is able to satisfy the requirements of this method.</td></tr></table>

# Note:

The use of the DMA feature inside Ethernet module requires the adoption of the set of safety mechanisms defined for DMA (refer to Section 3.6.12 Direct memory access controller and direct memory access request multiplexer (DMA, MDMA, BDMA, DMAMUX)).

# 3.6.50 HDMI-CEC (CEC)

Table 171. HDMI_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>HDMI_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method must be applied to CEC configuration registers.Detailed information on the implementation of this method can be found inSection 3.6. Extended interrupt and events controller XT.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

Table 172. HDMI_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=2 colspan=1>HDMI_SM_1Protocol error signals</td></tr><tr><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>ST</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>CEC communication module embeds protocol error checks (such as additional parity bitcheck, overrun, frame error) conceived to detect network-related abnormal conditions. Thesemechanisms are able anyway to detect a marginal percentage of hardware random failuresaffecting the module itself.Error signals connected to these checkers are normally handled in a standard communicationsoftware, so the overhead is reduced.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Error flag raise and optional interrupt event generation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on peripheral configuration (for instance baud rate). Refer to functionaldocumentation.</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Continuous</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>HDMI_SM_2: Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Enabling related interrupt generation on the detection of errors is highly recommended.</td></tr></table>

Table 173. HDMI_SM_2   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>HDMI_SM_2</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Information redundancy techniques on messages</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method is implemented adding to data packets transferred by CEC a redundancy check(such as CRC check, or similar one) with encoding capability. The checksum encodingcapability must be robust enough to guarantee at least 90% probability of detection for asingle bit flip in the data packet.Consistency of data packet must be checked by Application software before consuming data.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>On demand</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>It is assumed that the remote HDMI-CEC counterpart has an equivalent capability ofperforming the check described.To give an example on checksum encoding capability, using just a bit-by-bit addition isinappropriate.</td></tr></table>

# Disable and periodic cross-check of unintentional activation of unused peripherals

Tn el lat all.

Table 174. FFI_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FFI_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Disable of unused peripherals</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Thimetho cntrbutesheduction  e probability rossnteerences au perpherals ot used by the softwareapplication, in case a hardware failure causes unintentional activation.After the system boot, Application software must disable allunused peripherals with thisprocedure:Enable reset flag on AHB and APB peripheral reset register.Disable clock distribution on AHB and APB peripheral clock enable register.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Startup</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>FFI_SM_: Periodic read-back of interference avoidance registers</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>None</td></tr></table>

Table 175. FFI_SM_1   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>FFI_SM_1</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Periodic read-back of interference avoidance registers</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>This method contributes to the reduction of the probability of cross-interferences between llut unused peripherals. This diagnostic measure must be applied to following registers:•    clock enable and disable registersalternate function programming registersDetailed information on the implementation of this method can be found inSection 3.6.14 Extended interrupt and events controller (EXTI).</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Dependency on Device configuration</td><td rowspan=1 colspan=1>Refer to NVIC_ SM_0</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr><tr><td rowspan=1 colspan=1>Recommendations and known limitations</td><td rowspan=1 colspan=1>Refer to NVIC_SM_0</td></tr></table>

# 3.6.52 System

Table 176. DUAL_SM_0   

<table><tr><td rowspan=1 colspan=1>SM CODE</td><td rowspan=1 colspan=1>DUAL_SM_0</td></tr><tr><td rowspan=1 colspan=1>Description</td><td rowspan=1 colspan=1>Cross-check between two STM32 devices</td></tr><tr><td rowspan=1 colspan=1>Ownership</td><td rowspan=1 colspan=1>End user</td></tr><tr><td rowspan=1 colspan=1>Detailed implementation</td><td rowspan=1 colspan=1>Thi method s implemented in the spirit f technique described in IEC 61508-7, A.3.5 Reciprocal comparionbysotware&quot;, which is ated in EC6150Table. as capabletoachieve high level  diagnosticcoveageTewo proesg ni exchange at crocallyan a flharisononereas a dea failure in one of the two unit. The guidelines for the implementation are the following:Data exchanged include output results, intermediate resultand the results pass/fail  each softimplemented safety mechanisms executed on periodical basis on both MCUs (for example CPU_SM_0)Software routines devoted to data exchange/comparison must be logically separated from the softwareimplementing the safety function(s).Systematic capability of software implementing this method must be equal or above the one of thesoftware implementing the safety function(s).Independence and lack of interference between the software implementing the data exchange/comparison and the one implementing the safety function(s) must be proven.Frequency of data exchange/comparison is imposed by the system PST (refer to related timingconstraints for periodic safety mechanisms), except for output results which needs to be exchanged/compared at the same rate they are potentially updated.</td></tr><tr><td rowspan=1 colspan=1>Error reporting</td><td></td></tr><tr><td rowspan=1 colspan=1>Fault detection time</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Addressed fault model</td><td rowspan=1 colspan=1>Permanent/transient</td></tr><tr><td rowspan=1 colspan=1>Dependency on Deviceconfiguration</td><td rowspan=1 colspan=1>None</td></tr><tr><td rowspan=1 colspan=1>Initialization</td><td rowspan=1 colspan=1>Depends on implementation</td></tr><tr><td rowspan=1 colspan=1>Periodicity</td><td rowspan=1 colspan=1>Periodic</td></tr><tr><td rowspan=1 colspan=1>Test for the diagnostic</td><td rowspan=1 colspan=1>Not applicable</td></tr><tr><td rowspan=1 colspan=1>Multiple-fault protection</td><td rowspan=1 colspan=1>CPU_SM_0: Periodic core self-test software (individually executed on both processing units)</td></tr><tr><td rowspan=1 colspan=1>Recommendations andknown limitations</td><td rowspan=1 colspan=1>Tll  eibS.Reensfehiuyaycelysuch an architecture.This method can provide additional safety margin for systems that need further protection against faultaccumulation.Becuse his method could be potental sourccon cause ailure between thehael ncaseof incorrect implementation), End user is recommended to closely follow the Detailed implementationguidelines in this table.</td></tr></table>

the value of each variable able to directly influence the final individual channel output, such as:

variables included in computation of the final result; for example, of a PwM rate   
GPIO output is set high or low.

# 3.7 Conditions of use

The table below provides a summary of the safety concept recommendations reported in Section 3.6 Hardware and software diagnostics. The conditions of use to be applied to STM32H7 single-core series devices are reported in form of safety mechanism requirements. Exception is represented by some conditions of use iru  Ealyrderret res ciaiemodes.Tedits reported at the end of the table presented in this section.

Rank column reports how related safety mechanism has been considered during the analysis, with following meaning:

++ The safety mechanism is highly recommended as common practice. It is considered in this document for the cuationetwevisteentng eiosu a single MCU or up to SIL3 with two MCUs in1o02 scheme. Missing implementation may lead to invalidate any y (refer to Section 4.1.1 for guidance).   
+ The safetymechanism isrecommended as additional safety measure, ut not considered in this document r the coputation safetymetrics.Thend user can skip theimplementation incas  sn contradiction w functional requirements or overlapped by another mechanism ranked ++.   
0 it is related to a specific MCU configuration.

T Xmarke ernrastablolatha latfeani such fault model.

Table 177. List of safety recommendations   

<table><tr><td colspan="1" rowspan="1">Diagnostic</td><td colspan="1" rowspan="1">Description</td><td colspan="1" rowspan="1">Rank</td><td colspan="2" rowspan="1">Perm</td><td colspan="1" rowspan="1">Trans</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Arm® Cortex®-M7</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CPU_SM_0</td><td colspan="1" rowspan="1">Periodic core self-test software for Arm® Cortex®M7 CPU.</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CPU_SM_1</td><td colspan="1" rowspan="1">Control flow monitoring in Application software.</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CPU_SM_2</td><td colspan="1" rowspan="1">Double computation in Application software</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CPU_SM_3</td><td colspan="1" rowspan="1">Arm®Cortex®-M7 HardFault exceptions</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CPU_SM_4</td><td colspan="1" rowspan="1">Stack hardening for Application software</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CPU_SM_5</td><td colspan="1" rowspan="1">External watchdog</td><td colspan="1" rowspan="1">++(1)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CPU_SM_6</td><td colspan="1" rowspan="1">Independent watchdog</td><td colspan="1" rowspan="1">++(1)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CPU_SM_7</td><td colspan="1" rowspan="1">Memory protection unit (MPU).</td><td colspan="1" rowspan="1">++({2)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CPU_SM_9</td><td colspan="1" rowspan="1">Periodic self-test software for Arm®Cortex® -M7 caches</td><td colspan="1" rowspan="1">++(3)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">CPU_SM_10</td><td colspan="1" rowspan="1">ECC on Arm®Cortex® -M7 caches</td><td colspan="1" rowspan="1">++3)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">MPU_SM_0</td><td colspan="1" rowspan="1">Periodic read-back of MPU configuration registers</td><td colspan="1" rowspan="1">++(2)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">MPU_SM_1</td><td colspan="1" rowspan="1">MPU software test</td><td colspan="1" rowspan="1">0</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">System bus architecture/BusMatrix</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">BUS_SM_0</td><td colspan="1" rowspan="1">Periodic software test for interconnections</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">BUS_SM_1</td><td colspan="1" rowspan="1">Information redundancy in intra-chip data exchanges</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Embedded SRAM</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">RAM_SM_0</td><td colspan="1" rowspan="1">Periodic software test for static random access memory(SRAM)</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">RAM_SM_2</td><td colspan="1" rowspan="1">Stack hardening for Application software</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">RAM_SM_3</td><td colspan="1" rowspan="1">Information redundancy for safety-related variables in theApplication software</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">Diagnostic</td><td colspan="1" rowspan="1">Description</td><td colspan="1" rowspan="1">Rank</td><td colspan="2" rowspan="1">Perm</td><td colspan="1" rowspan="1">Trans</td></tr><tr><td colspan="1" rowspan="1">RAM_SM_4</td><td colspan="1" rowspan="1">Control flowmoitoring inApplication so</td><td colspan="1" rowspan="1">0(4)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">RAM_SM_5</td><td colspan="1" rowspan="1">Periodic integrity test for Application software in RAM</td><td colspan="1" rowspan="1">0(4)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">RAM_SM_6</td><td colspan="1" rowspan="1">Read protection (RDP)and write protection (WRP)</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">RAM_SM_7</td><td colspan="1" rowspan="1">ECC on SRAM</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">RAM_SM_8</td><td colspan="1" rowspan="1">icA</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Embedded flash memory</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">FLASH_SM_0</td><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">FLASH_SM_1</td><td colspan="1" rowspan="1">Control flowmonitoring inApplication so</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">FLASH_SM_2</td><td colspan="1" rowspan="1">Arm®orte®M7 HardFaultexctions</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">FLASH_SM_3</td><td colspan="1" rowspan="1">Option byte write protection</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">FLASH_SM_4</td><td colspan="1" rowspan="1">Static data encapsulation</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">FLASH_SM_6</td><td colspan="1" rowspan="1">Flash memory unused area iling code</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">FLASH_SM_7</td><td colspan="1" rowspan="1">ECC on flash memory</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">FLASH_SM_8</td><td colspan="1" rowspan="1">R ion RDP) r on WRP)potary code readout protection OP)</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">FLASH_SM_9</td><td colspan="1" rowspan="1">decoder</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Power controller (PWR)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">VSUP_SM_0</td><td colspan="1" rowspan="1">Periodic read-back of configuration registers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">VSUP_SM_1</td><td colspan="1" rowspan="1">Supply voltae teamoitorinPVD)</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">VSUP_SM_2</td><td colspan="1" rowspan="1">Independent watchdog</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">VSUP_SM_3</td><td colspan="1" rowspan="1">Internal temperature sensor ceck</td><td colspan="1" rowspan="1">-</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">VSUP_SM_5</td><td colspan="1" rowspan="1">Ssmve u nt</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Re and clock controller (RCC</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CLK_SM_0</td><td colspan="1" rowspan="1">Perdicead-bacniguration esters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CLK_SM_1</td><td colspan="1" rowspan="1">Clock security system (CSS)</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">CLK_SM_2</td><td colspan="1" rowspan="1">Independent watchdog</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CLK_SM_3</td><td colspan="1" rowspan="1">Internal clock cross-measurement</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Hardware semaphore (HSEM)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">HSEM_SM_0</td><td colspan="1" rowspan="1">Puan</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">HSEM_SM_1</td><td colspan="1" rowspan="1">Pbacguran</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">General-purpose input/output (GPIO)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">GPIO_SM_0</td><td colspan="1" rowspan="1">Pediceadbacguration esters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">GPIO_SM_1</td><td colspan="1" rowspan="1">1002 for input GPIO lines</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">GPIO_SM_2</td><td colspan="1" rowspan="1">Loacm u </td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">GPIO_SM_3</td><td colspan="1" rowspan="1">GPIO port configuration lock rgiter</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Debug system or peripheral control</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">DBG_SM_0</td><td colspan="1" rowspan="1">Watchdog protection</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">LOCK_SM_0</td><td colspan="1" rowspan="1">Lock mechanism for configuration options</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">System configuration controller (SYSCFG)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">SYSCFG_SM_0</td><td colspan="1" rowspan="1">Pedicead-bacnguration esters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">Diagnostic</td><td colspan="1" rowspan="1">Description</td><td colspan="1" rowspan="1">Rank</td><td colspan="2" rowspan="1">Perm</td><td colspan="1" rowspan="1">Trans</td></tr><tr><td colspan="1" rowspan="1">DIAG_SM_0</td><td colspan="1" rowspan="1">Peacarwaroscguaregisters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Direct memory access controller and direct memory access request multiplexer (DMA, MDMA, BDMA, DMAMUX)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">DMA_SM_0</td><td colspan="1" rowspan="1">Periodic read-back of configuration registers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">DMA_SM_1</td><td colspan="1" rowspan="1">Information redundancy on data packet transferred viaDMA</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">DMA_SM_2</td><td colspan="1" rowspan="1">Information redundancy by including sender or receiveridentfier n dat packensferre DMA</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">DMA_SM_3</td><td colspan="1" rowspan="1">Periodic software test for DMA</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">DMA_SM_4</td><td colspan="1" rowspan="1">DMA transaction awareness</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1">Chrom-Art Accelerator controller (DMA2D)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">DMA2D_SM_0</td><td colspan="1" rowspan="1">aut</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">DMA2D_SM_1</td><td colspan="1" rowspan="1">Periodic software test for DMA2D functions</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">DMA2D_SM_2</td><td colspan="1" rowspan="1">DMA processing and interrut waeness</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1">Extended interrupt and events controller (EXTI)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">NVIC_SM_0</td><td colspan="1" rowspan="1">Periodic read-back f configuration registers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">NVIC_SM_1</td><td colspan="1" rowspan="1">Expected and unexpected interrupt check</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1">Cyclic redundancy-check calculation unit (CRC)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CRC_SM_0</td><td colspan="1" rowspan="1">CRC self-coverage</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">CORDIC co-processor (CORDIC)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CORD_SM_0</td><td colspan="1" rowspan="1">cat</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CORD_SM_1</td><td colspan="1" rowspan="1">PaRDIC</td><td colspan="1" rowspan="1">++(5)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CORD_SM_2</td><td colspan="1" rowspan="1">CRDIC ® comparison by software</td><td colspan="1" rowspan="1">++(5)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CORD_SM_3</td><td colspan="1" rowspan="1">Double computation orCORDIC functions</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Filter math accelerator (FMAC)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">FMAC_SM_0</td><td colspan="1" rowspan="1">ut</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">FMAC_SM_1</td><td colspan="1" rowspan="1">Periodic software test for FMAC functions</td><td colspan="1" rowspan="1">++(6)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">FMAC_SM_2</td><td colspan="1" rowspan="1">FMAC/Arm Cortex-M7 periodic reciprocal comparison bysoftware</td><td colspan="1" rowspan="1">++(6)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">FMAC_SM_3</td><td colspan="1" rowspan="1">Double computation for FMAC functions</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Flexible static memory controller (FSMC)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">FSMC_SM_0</td><td colspan="1" rowspan="1">Control flonitring in Application</td><td colspan="1" rowspan="1">++(7)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">FSMC_SM_1</td><td colspan="1" rowspan="1">Information redundancy on external memory connectedto FSMC</td><td colspan="1" rowspan="1">++(7)</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">FSMC_SM_2</td><td colspan="1" rowspan="1">Periodic read-back of FSMC configuration registers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">FSMC_SM_3</td><td colspan="1" rowspan="1">ECC engine on NAND interface in FSMC module</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Quad-SPI / Octo-SPI interface (QUADSPI/OCTOSPI)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">QSPI_SM_0</td><td colspan="1" rowspan="1">Periodic read-back of QUADSPI/OCTOSPI configurationregisters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">QSPI_SM_1</td><td colspan="1" rowspan="1">Prool e sigalsincludin hardwa</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">QSPI_SM_2</td><td colspan="1" rowspan="1">Information redundancy techniques on messages</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Delay block (DLYB)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">DLB_SM_0</td><td colspan="1" rowspan="1">baL</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">Diagnostic</td><td colspan="1" rowspan="1">Description</td><td colspan="1" rowspan="1">Rank</td><td colspan="2" rowspan="1">Perm</td><td colspan="1" rowspan="1">Trans</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Analog-to-digital converter (ADC)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">ADC_SM_0</td><td colspan="1" rowspan="1">Pead-acuration sr</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">ADC_SM_1</td><td colspan="1" rowspan="1">Multiple acquisition by Application sowa</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">ADC_SM_2</td><td colspan="1" rowspan="1">Range check by Application software</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">ADC_SM_3</td><td colspan="1" rowspan="1">Peric sotware test or ADC</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">ADC_SM_4</td><td colspan="1" rowspan="1">1002 scheme for ADC inputs</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Digital-to-analog converter (DAC)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">DAC_SM_0</td><td colspan="1" rowspan="1">Pedicead-bacnguration esters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">DAC_SM_1</td><td colspan="1" rowspan="1">DACoutput loopback on ADC channel</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Voltage reference buffer (VREFBUF)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">VREF_SM_0</td><td colspan="1" rowspan="1">Perdic read-back of VREFBUF system configurationregisters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">VREF_SM_1</td><td colspan="1" rowspan="1">VREF cross-check by ADC reading</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Comparator (COMP)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">COMP_SM_0</td><td colspan="1" rowspan="1">Pacuran</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">COMP_SM_1</td><td colspan="1" rowspan="1">1002 scheme for comparator</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">COMP_SM_2</td><td colspan="1" rowspan="1">Plausibility ecu</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">COMP_SM_3</td><td colspan="1" rowspan="1">Multiple acquisition byApplication so</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">COMP_SM_4</td><td colspan="1" rowspan="1">Comparator lock mechanism</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Operational amplifiers (OPAMP)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">AMP_SM_0</td><td colspan="1" rowspan="1">Pe ead-ac OPAM graton ters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Digital flter for sigma delta modulators (DFSDM)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">DFS_SM_0</td><td colspan="1" rowspan="1">icead-acDFSDM coigurati reste</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">DFS_SM_1</td><td colspan="1" rowspan="1">Multiple acquisition by Application software</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">DFS_SM_2</td><td colspan="1" rowspan="1">Rag heck yApplitio </td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">DFS_SM_3</td><td colspan="1" rowspan="1">102 scheme for DFSM inuts</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Digital camera interface (DCMI)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">DCMI_SM_0</td><td colspan="1" rowspan="1">Pec read-bac  DCMI coniguratin registers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">DCMI_SM_1</td><td colspan="1" rowspan="1">DCMI video input data synchronization</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">LCD-TFT display controller (LTDC)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">LCD_SM_0</td><td colspan="1" rowspan="1">ac  bufer memory</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">LCD_SM_1</td><td colspan="1" rowspan="1">LTDC acquisiton by ADC channel</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">JPEG codec (JPEG)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">JPEG_SM_0</td><td colspan="1" rowspan="1">bacJEogat </td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">JPEG_SM_1</td><td colspan="1" rowspan="1">Periodic test for JPEG encoding/decoding functions</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">JPEG_SM_2</td><td colspan="1" rowspan="1">Alaton-veiocoding/encoding</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">True random number generator (RNG)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">RNG_SM_0</td><td colspan="1" rowspan="1">Perc read-bacRNG configuration ter</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">RNG_SM_1</td><td colspan="1" rowspan="1">RNG module entropy on-line tests</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">Diagnostic</td><td colspan="1" rowspan="1">Description</td><td colspan="1" rowspan="1">Rank</td><td colspan="2" rowspan="1">Perm</td><td colspan="1" rowspan="1">Trans</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Cryptographic processor (CRYP)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CRYP_SM_0</td><td colspan="1" rowspan="1">Peic read-bac R cnfiguration eisters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CRYP_SM_1</td><td colspan="1" rowspan="1">Encryption/decryptioncollateral detcio</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CRYP_SM_2</td><td colspan="1" rowspan="1">Information redundancy techniques on messages,cinon</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">HASH processor (HASH)</td><td colspan="1" rowspan="1"></td><td colspan="3" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">HASH_SM_0</td><td colspan="1" rowspan="1">P readbac HASH cguratin srs</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">HASH_SM_1</td><td colspan="1" rowspan="1">HASH processing collateral detection</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">On-the-fly decryption engine (OTFDEC)</td><td colspan="1" rowspan="1"></td><td colspan="3" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">OTFDEC_SM_0</td><td colspan="1" rowspan="1">Pedcal read-bac OTFDECconiguratin egisters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">OTFDEC_SM_1</td><td colspan="1" rowspan="1">OTFDEC encryption/decryption collateral detection</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">OTFDEC_SM_2</td><td colspan="1" rowspan="1">A Crte®7 ardFauti</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">OTFDEC_SM_3</td><td colspan="1" rowspan="1">Static data encapsulation</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Advanced-control/General-purpose/High resolution and low-power timers</td><td colspan="1" rowspan="1"></td><td colspan="3" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">ATIM_SM_0</td><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">ATIM_SM_1</td><td colspan="1" rowspan="1">1002 for counting timers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">ATIM_SM_2</td><td colspan="1" rowspan="1">1002 for input capture timers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">ATIM_SM_3</td><td colspan="1" rowspan="1">Loopback scheme for pulse width modulation (PWM)outputs</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">ATIM_SM_4</td><td colspan="1" rowspan="1">Lock bit rotection orimers</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Basic timers</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">GTIM_SM_0</td><td colspan="1" rowspan="1">Peicead-backnfiguration reisers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">GTIM_SM_1</td><td colspan="1" rowspan="1">1002 for counting timers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Independent and system window watchdogs (IWDG and WWDG)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">WDG_SM_0</td><td colspan="1" rowspan="1">au</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">WDG_SM_1</td><td colspan="1" rowspan="1">S </td><td colspan="1" rowspan="1">0</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Real-time clock module (RTC)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">RTC_SM_0</td><td colspan="1" rowspan="1">bacut</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">RTC_SM_1</td><td colspan="1" rowspan="1">Application check of running RC</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">RTC_SM_2</td><td colspan="1" rowspan="1">Inrmation redundancy n backupegsters</td><td colspan="1" rowspan="1">0</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">RTC_SM_3</td><td colspan="1" rowspan="1">Application-level measures to detect failures intimestamps/event capture</td><td colspan="1" rowspan="1">0</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Tamper and backup registers (TAMP)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">TAMP_SM_0</td><td colspan="1" rowspan="1">Inforationrundancamper acku </td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Inter-integrated circuit (2C)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">IIC_SM_0</td><td colspan="1" rowspan="1">Peibacgraton</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">IIC_ SM_1</td><td colspan="1" rowspan="1">Protocol error signals</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">IIC_SM_2</td><td colspan="1" rowspan="1">Information redundancy techniques on messages</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">IIC_ SM_3</td><td colspan="1" rowspan="1">CRC packet-level</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">IIC_ SM_4</td><td colspan="1" rowspan="1">Information redundancy techniques on messages,ncluding end-to-end roteo</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="6" rowspan="1">Uv  R,UART, LPUART)</td></tr><tr><td colspan="1" rowspan="1">UART_SM_0</td><td colspan="1" rowspan="1">Periodic read-back of configuration registers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">UART_SM_1</td><td colspan="1" rowspan="1">Protocol error signals</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">UART_SM_2</td><td colspan="1" rowspan="1">Information redundancy techniques on messages</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">UART_SM_3</td><td colspan="1" rowspan="1">Information redundancy techniques on messages,including end-to-end protection</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Serial peripheral interface (SPI)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">SPI_SM_0</td><td colspan="1" rowspan="1">Perdicdbaciguration ters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">SPI_SM_1</td><td colspan="1" rowspan="1">Protocol error signals</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">SPI_SM_2</td><td colspan="1" rowspan="1">Information redundancy techniques on messages</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">SPI_SM_3</td><td colspan="1" rowspan="1">CRC packet-level</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">SPI_SM_4</td><td colspan="1" rowspan="1">Information redundancy echniques on mesges,including end-to-end protection</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Serial audio interface (SAI)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">SAI_SM_0</td><td colspan="1" rowspan="1">bc</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">SAI_SM_1</td><td colspan="1" rowspan="1">SAloutput loopback scheme</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">SAI_SM_2</td><td colspan="1" rowspan="1">1002 scheme for SAI module</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">SPDIF receiver interface (SPDIFRX)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">SPDF_SM_0</td><td colspan="1" rowspan="1">baca </td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">SPDF_SM_1</td><td colspan="1" rowspan="1">Protocol error signals</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">SPDF_SM_2</td><td colspan="1" rowspan="1">Information redundancy techniques on messages</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Single Wire Protocol Master Interface (SWPMI)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">SWPMI_SM_0</td><td colspan="1" rowspan="1">u</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">SWPMI_SM_1</td><td colspan="1" rowspan="1">o alincluding hardware CRC</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">SWPMI_SM_2</td><td colspan="1" rowspan="1">SWMPI loopback test</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1">SWPMI_SM_3</td><td colspan="1" rowspan="1">Information redundancy techniques on messages toimplement full end-to-end operation</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Management data input/output (MDIOS)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">MDIO_SM_0</td><td colspan="1" rowspan="1">acvuat </td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">MDIO_SM_1</td><td colspan="1" rowspan="1">Protocol error signals</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">MDIO_SM_2</td><td colspan="1" rowspan="1">contents, including register update awareness</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Secure digital input/output MultiMediaCard interface (SDMMC)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">SDIO_SM_0</td><td colspan="1" rowspan="1">Periodic read-back of SDIO/SMMC configurationreggisters</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">SDIO_SM_1</td><td colspan="1" rowspan="1">Pool erroals ncluding hardwar</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">SDIO_SM_2</td><td colspan="1" rowspan="1">Information redundancy techniques on messages</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Controller area network (FDCAN)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CAN_SM_0</td><td colspan="1" rowspan="1">Pice-bacguraton e</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CAN_SM_1</td><td colspan="1" rowspan="1">Protocol error signals</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">CAN_SM_2</td><td colspan="1" rowspan="1">Inforation redundancy techniques onmessages,ncuding endo-nd o</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">USB on-the-go high-speed (OTG_HS)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">USB_SM_0</td><td colspan="1" rowspan="1">Periodic read-back of configuration registers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">USB_SM_1</td><td colspan="1" rowspan="1">Protocol error signals</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">USB_SM_2</td><td colspan="1" rowspan="1">Information redundancy techniques on messages</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">USB_SM_3</td><td colspan="1" rowspan="1">Information redundancy techniques on messages,including end-to-end protection.</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Ethernet (ETH): media access control (MAC) with DMA controller</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">ETH_SM_0</td><td colspan="1" rowspan="1">Periodic read-back of Ethernet configuration registers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">ETH_SM_1</td><td colspan="1" rowspan="1">Protocol error signals including hardware CRC</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">ETH_SM_2</td><td colspan="1" rowspan="1">Information redundancy techniques on messages,including end-to-end protection</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">HDMI-CEC (CEC)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">HDMI_SM_0</td><td colspan="1" rowspan="1">acut</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1">HDMI_SM_1</td><td colspan="1" rowspan="1">Protocol error signals</td><td colspan="1" rowspan="1">+</td><td colspan="2" rowspan="1">×</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1">HDMI_SM_2</td><td colspan="1" rowspan="1">Information redundancy techniques on messages</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">×</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Disable and periodic cross-check of unintentional activation ofunused peripherals</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">FFI_SM_0</td><td colspan="1" rowspan="1">Disablenused peripherals</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">FFI_SM_1</td><td colspan="1" rowspan="1">Peridic read-back of interference avoidance registers</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Arm®Cortex®-M7 CPU</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CoU_1</td><td colspan="1" rowspan="1">The reset condition of Arm® Cortex® M7 CPU must becompatible as valid safe state at system level</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Debug</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CoU_2</td><td colspan="1" rowspan="1">Device debug features must not be used in safetyfunction(s) implementation.</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1">-</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Arm®Cortex®-M7 / Supply system</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CoU_3</td><td colspan="1" rowspan="1">Low-powermode ate must ot  se  feyfunction(s) implementation.</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">-</td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Device peripherals</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CoU_4</td><td colspan="1" rowspan="1">End user must implement the required combination ofsafety mechanism/CoUs for each STM32 peripheral usedin implementation of safety function(s).</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Flash memory subsystem</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CoU_5</td><td colspan="1" rowspan="1">During flash memory bank mass erase andreprogramming there must not be safety functions(s)executed by Device.</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CoU_6</td><td colspan="1" rowspan="1">On-field application software liveupdate by dual-Flashsystem must include the execution of code/data integritycheck by methods like FLASH_SM_0.</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">CPU subsystem</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CoU_7</td><td colspan="1" rowspan="1">In case of multiple safety functions implementations,methods to guarantee their mutual independence mustinclude MPU use.</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1">Clock recovery system (CRS)</td><td colspan="1" rowspan="1"></td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">CoU_8</td><td colspan="1" rowspan="1">CRS  usou  implementation.</td><td colspan="1" rowspan="1">++</td><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="5" rowspan="1">System</td></tr><tr><td colspan="1" rowspan="1">DUAL_SM_0</td><td colspan="1" rowspan="1">Cross-check between two STM32 devices</td><td colspan="1" rowspan="1">0</td><td colspan="2" rowspan="1">X</td><td colspan="1" rowspan="1">X</td></tr></table>

Section 3.6 Hardware and software diagnostics for more details.

no need to be executed

4. Must be considered ranked as "++" if Application software is executed on RAM.

5. CORDOR CORD_SM_1 or CORD_SM_2.

MACA either of them.

Can be considered ranked as "o" depending on the intended use of external memory connected to FSMC.

The above-describe safey mechanism or conditions fusear conceived wit different levels ofabstracton dinauoyeaniplentlicationdpenden its possible use on a large range of End user applications.

The safety analysis highlights two major partitions inside the MCU:

EveryEnd userapplication is affected, from safety point ofview, by a failure on thesemodules. Because they are used by every End user application, related methods or safety mechanism are mainly conceived to be application-independent. The system-critical modules on Device are: CPU, RCC, PWR, bus matrix and interconnect, and flash memory and RAM (including their interfaces).

# Peripheral modules

Such modules could be not used by the end-user application, or they could be used for non-safety elated tasks. Related safety methods are therefore implemented mainly at application level, as Application software solutions or architectural solutions.

# 4 Safety results

Th ecreportsheesult esafey analysgle-core er evis IEC 61508 and to ST methodology flow, related to the hardware random and dependent failures.

# Random hardware failure safety results

Tnalyndarwarilure gle-corevisorth afey is executedaccording to STMicroelectronics methodology flow or safety analysis semiconductordevices in coliance wit  08 reer  [] o more detailsTheccuracy resultbtaine aguaran y three factors:

STMicroelectronics methodology flow strict adherence to IEC 61508 requirements and prescriptions the use, during the analysis, of detailed and reliable information on microcontroller design tueovealattahr u ine safety metrics verification

TDevenalypl ivDeiv e  them anadequatemitigation measure (afety mechanism). The overll list  Device ailuemodes is maintained in the relatedFMEA document [], provided on demand by local STMicroelectronics sales office.

In sumary, with he doption  he afeymechanisms n condition usereporte  Section Contin of use, it is possible to achieve the integrity levels summarized in the following table.

Table 178. Overall achievable safety integrity levels   

<table><tr><td rowspan=1 colspan=1>Number ofDevices used</td><td rowspan=1 colspan=1>Safetyarchitecture</td><td rowspan=1 colspan=1>Target</td><td rowspan=1 colspan=1>Safety analysis result</td></tr><tr><td rowspan=2 colspan=1>1</td><td rowspan=2 colspan=1>1001</td><td rowspan=1 colspan=1>SIL2 LD</td><td rowspan=1 colspan=1>Achievable</td></tr><tr><td rowspan=1 colspan=1>SIL2 HDICM</td><td rowspan=1 colspan=1>Achievable with potential performance impact </td></tr><tr><td rowspan=2 colspan=1>2</td><td rowspan=2 colspan=1>1002</td><td rowspan=1 colspan=1>SIL3 LD</td><td rowspan=1 colspan=1>Achievable</td></tr><tr><td rowspan=1 colspan=1>SIL3 HDICM</td><td rowspan=1 colspan=1>Achievable with potential performance impact</td></tr></table>

theri eao "hese  s Scn assumptions).

fiour  abileailo or c the failure mode effect diagnostic analysis (FMEDA) snapshot [2], due to:

a large number of different STM32H7 single-core series parts, a possibility to declare non-safety-relevant unused peripherals, and a possibility to enable or not the different available safety mechanisms

The MEAot [] isaoe ornghe yeufnt etl ev olcatiani give par number.  MEAdocument ineede contact helocal Microelectronic ale eresentativ ey as possible, in order toreceive iformation n expecte delivery dates orspecii Device target part numbers.

# Note:

Safety metrics computations are restricted to STM32H7 single-core series boundary, hence they do not include the WDTe, PEv, and VMONe processes described in Section 3.3.1 Safety requirement assumptions).

# 4.1.1

# Safety analysis result customization

The safety analysis executed for STM32H7 single-core series devices documented in this safety manual al otrollerosvrelplcatea role has been declared safe as per IEC 61508-4, 3.6.8. Therefore, ll microcontrollermodules are included in SFF computations.

In actual End user applications, not allthe STM327 single-core series parts ormodules implement a safety function. That happens if:

The part is not used at all (disabled), or   
The part implements functions that are not safety-related (for example, a GPlO line driving a power-on signaling light on an electronic board).

# Note:

Implementation of non-safety-related functions is in principle forbidden by the assumed safety requirement ASR6 (see Section 3.3.1 Safety requirement assumptions), hence under End user's entire reponsibility.As any other derogation from safety requrements included in this manual, it is Enduser's responsibility to provide consistent rationales and evidences that the function does not bring additional risks, by following the procedure described in this section. Therefore, it is strongly recommended to reserve such derogation to very simple functions (as the one provided in the example).

Implementing safety mechanisms on such parts would be a useless effort for End user. The safety analysis results can therefore be customized.

End user can define a STM32H7 single-core series part as non-safety-related based on:

D Collecting rationales and evidences that the part does not contribute to safety function.

Collecting rationales and evidences that the part does not interfere with the safetyunction during normal operation, due to final system design decisions. Mitigation of unused modules is exhaustively addressed in Section 4.1.2 General requirements for freedom from interferences (FFI).

Fulfilling the general condition for the mitigation of intra-MCU interferences (see Section 4.1.2 General requirements for freedom from interferences (FFI)).

For a non-safety-related part, End user is allowed to:

• Exclude the part from computing metrics to report in FMEDA, and

Not implement safety mechanisms as listed in Table 177. List of safety recommendations.

With regard to SFF computation, this secton complies with the o part / o effect defiition as per IEC 61508-, 3.6.13 / 3.6.14.

# General requirements for freedom from interferences (FFl)

Adedicateanalyssasihlhteda lsgeneral uments ellwerdritgat pl interencs etweevinteralmodulecasntenal ilur reem ominteerenc FFl). T v nu microcontroller modules are declared as non-safety-related by End user as per Section 4.1.1 Safety analysis result customization.

End user must implement the safety mechanisms listed in Table 179 (implementation details in Sraastiardelatun.

Table 179. List of general requirements for FFl   

<table><tr><td rowspan=1 colspan=1>Diagnostic</td><td rowspan=1 colspan=1>Description</td></tr><tr><td rowspan=1 colspan=1>BUS_SM_0</td><td rowspan=1 colspan=1>Periodic software test for interconnections</td></tr><tr><td rowspan=1 colspan=1>GPIO_SM_0</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>DMA_SM_0</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>DMA_SM_2</td><td rowspan=1 colspan=1>Information redundancy by including sender or receiver identifier on data packet transferred via DMA(</td></tr><tr><td rowspan=1 colspan=1>DMA_SM_4</td><td rowspan=1 colspan=1>DMA transaction awareness(1)</td></tr><tr><td rowspan=1 colspan=1>NVIC_SM_0</td><td rowspan=1 colspan=1>Periodic read-back of configuration registers</td></tr><tr><td rowspan=1 colspan=1>NVIC_SM_1</td><td rowspan=1 colspan=1>Expected and unexpected interrupt check</td></tr><tr><td rowspan=1 colspan=1>FFI_SM_0</td><td rowspan=1 colspan=1>Disable of unused peripherals</td></tr><tr><td rowspan=1 colspan=1>FFI_SM_1</td><td rowspan=1 colspan=1>Periodic read-back of interference avoidance registers</td></tr></table>

To be implemented only if DMA is actually used.

# 4.1.3

# Notes on multiple-fault scenario

According to the requirements of IEC 61508, the safety analysis for STM32H7 single-core series devices u u aortayalalga peenyeniiur Multipleault protection feld thetablesSection3. Harwarean softwaredagnostic eport they aniuoultpleul atesas making safety mechanisms ineffective. It is strongly recommended that the safety concept includes such mitgaion measures, and in particular or systes operating durig log perid, as theytend toacculate es. Indeeul accumulation issuehas been taken intaccount during 32 ingle-coreser evic safety analysis.

Anoteptent urultitionulation eanentluur o e saety mechanism at each system power-up; this measure guarantees a fresh system start with a fault-ree hardware.This recommendation is given for periodic safety mechanisms rated as "++" (highly recommended) in theDevic safey concpt,and mainly r hemost elevant ones n term  failure istriution:SM_, FLASH_SM_0, RAM_SM_0. This startup execution is strongly recommended regardless the safety functions mode of operations and/or the value of PST.

# 4.2

# Analysis of dependent failures

The analysis of dependent failures is important for microcontroller and microprocessor devices.The main subclasses of dependent failures are CCFs.Their analysis s ruled by IEC 61508-2annex E, which lists the l semiconductor substrate.

As there is no on-chip redundancy n STM32H7 single-core series devices, the CCF quantification through the ueteeso ioteha ineca oy architecture implementation, End user is required to evaluate the β and βD parameters (used in PFH computation) that reflect the common cause factors between the two channels.

Tvu  al following sections. The safety mechanisms referred to are described in Section 3.6 Hardware and software diagnostics.

# .2.1

# Power supply

t modules, leading to notindependent failures. The following safetymechanisms address andmitigate those dependent failures:

VSUP_SM_1: detection of abnormal value of supply voltage;   
VSUPSM2: the independent watchdog is different from the digital core of the MCU, and this diversity helps to mitigate dependent failures related to the main supply alterations. As reported in VSUP_SM_2 description, separate power supply for IWDG or/and the adoption of an external watchdog (CPU_SM_5) increase such diversity.   
VSUP_sM_5: power supply stability (guaranteed by system level measures) is an important mitigation factor

Theadoption uc safeymechanismssthereforehighly ecomendedespiteheminorcontribution e yei a e sfe riyR Scn. WR) detailed safety mechanism descriptions.

# 4.2.2 Clock

Systm clocka potentil sourcedependent ailures,because alterations heclock haracts nf ar dodee iluTeolleye address and mitigate such dependent failures:

CLK_SM_1: the clock security system is able to detect hard alterations (stop) of system clock and activate the adequate recovery actions.

CLK_SM_2: the independent watchdog has a dedicated clock source. The frequency alteration of the system clock leads to the watchdog window violations by the triggering routine on Application software, leading to the MCU reset by watchdog. The adoption of external watchdog (CPU_SM_5) provides additional diversity and so further mitigation of clock-related common cause failures.

Theadoption uc safeymehanihereforehihly ecomende dspihmior contribution e y R Seccol RCC for detailed safety mechanisms description.

# 4.2.3 DMA

ThMAfunction can bnvolve indattransferoerate bymost the peripherals. ailure DMA c iha pl e i adoption f the following safety mechanisms is therefore highly recommended (refer to Section3.6. Direct memory access controller and direct memory access request multiplexer (DMA, MDMA, BDMA, DMAMUX) for description):

DMA_SM_0   
DMA_SM_1   
DMA_SM_2

# Note:

)nly DMA_ SM_0 must be implemented if DMA is not used for data transfei

# 4.2.4 Internal temperature

Ta man MC parts The following safety mehanism mitigates this potential effect (reer to Secion ..5owe controller (PWR) for description):

VSUPMetal eacheallose icye o before they lead to a series of internal failures.

# 5 List of evidences

conclusions reported in this safety manual.

The safety case database is composed of the following:

safety case with the full list of all safety-analysis-related documents   
STMicroelectronics' internal FMEDA tool database for the computation of safety metrics, including estimated and measured values   
safety report, a document that describes in detail the safety analysis executed on STM32H7 single-core series devices and the compliance to IEC 61508 applicable clauses   
STMicroelectronics' internal fault injection campaign database including tool configuration and settings, fault injection logs and results, related to the McU modules for which fault injection is adopted as verification method.

ne audit and inspection by authorizd bodies,without beig published, which conforms to Note  f IEC 6508, 7.4.9.7.

# Important:

The combination of this document (safety manual), the [1] and [2] documents, the [4] provides per se an exhaustive view of the rationales for the compliance to IEC 61508 requirements of the whole STM32 safety cot.l heent vailbler Dndhenha wiiattit applicable NDA for details).

# Appendix A X-CUBE-STL self-test software library

The X-CUBE-TL also eferre as "STL in thidocent)s  Softae-basdignosibrary dsie to detc random hardware failures in STM32 safety-critical corecomponents (CPU + SRAM + flash memory). It is provided by TMicroelectronics to simplify the plementation  M32 MCU safety concept, b offerin pcertified brick addressing the most challenging MCU functions.

X-CUBE-STL implements a set of of key safety mechanisms described in this Safety Manual:

CPU_SM_0 Periodic core self-test software for CPU.   
FLASH_SM_0 Periodic software test for flash memory   
RAM_SM_0 Periodic software test for static random access memory (SRAM)

![](images/915db7409640aa489b67a86ad69921dcbdd6ba310f20f65c00883f6bb2341f8e.jpg)  
Figure 6. STL architecture

Legend: STL User

# X-CUBE-STL characteristics:

Partitioned into Test Modules to ease its coexistence with end user application software   
Provided with a Scheduler function to simplify the periodic execution of the tests   
Flash and SRAM test area can be partitioned in programmable sections to reduce the time for the execution of atomic test sections   
Application independent: can be used in potentially any end-user application.   
It can be interrupted at practically any time by the end user application; the few critical sections are automatically protected by an interrupt disable function.   
Compiler independent: delivered as object code.   
Independence: designed as HAL-, BSP- and CMSIS-agnostic (there are no dependencies from these software packages).   
Compatible with most popular safe RTOS (white papers/application notes on integration with safe RTOS are available)   
Portability: the X-CUBE-STL shares the same APIs set across all the STM32 MCU Series, so projects portability across STM32 portfolio is guaranteed   
Provided with exhaustive end user documentation: safety manual and user guide

Diosticoverageverif bystae-he  proritary ult injectionmetho Development flow compliant to SC3 systematic capability requirements from IEC 61508 Certified by TÜV Rheinland (certification covers claims related to achieved DC and SC3 development flow) X-CUBE-STL is available on demand under NDA agreement (contact your local ST representative).

# Revision history

Table 180. Document revision history   

<table><tr><td colspan="3" rowspan="3">Date              Revision                                    Changes18-Dec-2017               1      Initial release.</td></tr><tr><td colspan="1" rowspan="1">Date</td><td colspan="1" rowspan="1">Revision</td></tr><tr><td colspan="1" rowspan="1">18-Dec-2017</td><td colspan="1" rowspan="1">1</td></tr><tr><td colspan="1" rowspan="1">19-Apr-2018</td><td colspan="1" rowspan="1">2</td><td colspan="1" rowspan="1">Updated:IntroductionSection 1.2 Normative references'change impact analysis for other safety standards' and ISO13849works products' paragraphsSection 6.2 IEC 62061:2005+AMD1:2012+AMD2:2015Table 164. ISO 13849 architectural categoriesFigure 6, figure 7 and figure 8'SIL classification versus HFT' tableRemoved former Section A.4: IEC 60730-1:2010.Minor text edits across the whole document.</td></tr><tr><td colspan="1" rowspan="1">06-Dec-2018</td><td colspan="1" rowspan="1">3</td><td colspan="1" rowspan="1">Updated Section 6.1.2 ISO 13849 safety metrics computation.</td></tr><tr><td colspan="2" rowspan="1">13-Jan-2020               4</td><td colspan="1" rowspan="1">Updated functional safety documentation framework.Added:Section 1.3 Reference documentsSection 3.6.24 Clock recovery system (CRS)Updated:IntroductionSection 1.2 Normative referencesSection 2 Device development processSection 3.2.2 Safety functions performed by Compliant itemSection 3.2.4 Reference safety architectures - 1002Section 3.3.1 Safety requirement assumptions all Devices functionsSection 3.6.2 Embedded Flash memorySection 3.6.21 Power controller (PWR) adding VSUP_SM_5Section 3.7 Conditions of useSection 4.1.3 Notes on multiple-fault scenario adding paragraph on faultaccumulation issueSection 4.2 Analysis of dependent failuresSection 6 Change impact analysis for other safety standardsSection 6.1.1 IS0 13849 architectural categoriesSection 6.1.2 IS0 13849 safety metrics computationSection 6.2 IEC 62061:2005+AMD1:2012+AMD2:2015Section 6.2.1 IEC 62061 architectural categoriesSection 6.2.2 IEC 62061 safety metrics computationSection 6.3 IEC 61800-5-2:2016Section 6.3.1 IEC 61800 architectural categoriesSection 6.3.2 IEC 61800 safety metrics computationChanged appendix in paragraphs.Removed:ISO 13849 work products from Section 6.1 ISO 13849-1:2015, ISO13849-2:2012ISO 62061 work products from Section 6.2 IEC62061:2005+AMD1:2012+AMD2:2015IEC 61800 work products from Section 6.3 IEC 61800-5-2:2016</td></tr><tr><td colspan="1" rowspan="1">17-Feb-2020</td><td colspan="1" rowspan="1">5</td><td colspan="1" rowspan="1">Updated:CPU_SM_10 in Section 3.6.1 Arm Cortex-M7 CPUFLASH_SM_7 in Section 3.6.2 Embedded Flash memory</td></tr><tr><td colspan="1" rowspan="1">27-May-2020</td><td colspan="1" rowspan="1">6</td><td colspan="1" rowspan="1">Updated:Introduction</td></tr><tr><td colspan="1" rowspan="1">Date</td><td colspan="1" rowspan="1">Revision</td><td colspan="1" rowspan="2">ChangesSection 1.1 Purpose and scopeSection 3 Reference safety architectureSection 3.5 Systematic safety integritySection 3.6.35 Management data input/output (MDIOS)</td></tr><tr><td colspan="1" rowspan="1"></td><td colspan="3" rowspan="1"></td></tr><tr><td colspan="1" rowspan="1">02-Mar-2021</td><td colspan="1" rowspan="1">7</td><td colspan="1" rowspan="1">Replaced STM32H7 Series by STM32H7 single-core in the whole document.Updated:Table 12. CPU_SM_10Table 22. FLASH_SM_9Table 30. RAM_SM_8</td></tr><tr><td colspan="1" rowspan="1">12-Oct-2021</td><td colspan="1" rowspan="1">8</td><td colspan="1" rowspan="1">Added:Section 3.6.17 Filter math accelerator (FMAC)Section 3.6.16 CORDIC co-processor (CORDIC)Section 3.6.31 On-the-fly decryption engine (OTFDEC)Updated:Table 31. FLASH_SM_7 (bus error is generated, was NMI)Section 3.6.19 Quad-SPI / Octo-SPI interface (QUADSPI/OCTOSPI)Table 142. SPI_SM_2Table 177. List of safety recommendations (table title)</td></tr><tr><td colspan="1" rowspan="1">03-Oct-2023</td><td colspan="4" rowspan="1">Updated:Section 3.2.2 Safety functions performed by Compliant itemSection 3.2.4 Reference safety architectures - 1002Section 3.3.1 Safety requirement assumptionsSection 3.5 Systematic safety integrityMinor updates of tables and table titles in Section 3.6 Hardware andsoftware diagnosticsSection 3.6.12 Direct memory access controller and directmemory access request multiplexer (DMA, MDMA, BDMA,DMAMUX)Section 3.6.34 Advanced-control/General-purpose/High resolutionand low-power timersSection 3.6.35 Basic timers9                   Section 3.6.40 Universal synchronous/asynchronous receiver/transmitter and low power universal asynchronous receiver/transmitter (USART, UART, LPUART)Section 3.6.46 Secure digital input/output MultiMediaCardinterface (SDMMC)Section 4.1 Random hardware failure safety resultsTable 178. Overall achievable safety integrity levelsSection 4.1.1 Safety analysis result customizationSection 4.2.1 Power supplySection 5 List of evidencesAdded:Appendix A X-CUBE-STL self-test software libraryReplacement of Flash by flash in the document.</td></tr></table>

# Glossary

Application software within the software executed by Device, the part that ensures functionality of End user's application and integrates safety functions

ASR assumed safety requirement

CCF common cause failure

CM continuous mode

Compliant item any item subject to claim with respect to the clauses of IEC 61508 series of standards

COTS commercial off-the-shelf

CoU conditions of use

CPU central processing unit

CRC cyclic redundancy check

DC diagnostic coverage

Device depending on context, any single or all of the silicon products

DMA direct memory access

DTI diagnostic test interval

End user individual person or company who integrates Device in their application, such as an electronic control board

EUC equipment under control

FIT failure in time

FMEA failure mode effect analysis

FMEDA failure mode effect diagnostic analysis

HD high-demand

HFT hardware fault tolerance

HW hardware

ITRS international technology roadmap for semiconductors

LD low-demand   
MCU microcontroller unit   
MPU memory protection unit   
MTBF mean time between failures   
MTTFd mean time to dangerous failure   
NDA non disclosure agreement   
PEc computation processing elements   
PEi input processing elements   
PEo output processing elements   
PEv voting processing element   
PFD probability of dangerous failure on demand   
Pprobability of failure per hour   
PL performance level   
PST process safety time   
SFF safe failure fraction   
SIL safety integrity level   
SoC system on chip   
VMONe voltage monitors   
WDTe watchdog

# Contents

# 1 About this document

1.1 Purpose and scope.   
1.2 Normative references   
1.3 Reference documents.

# Device development process 3

# Reference safety architecture . 4

3.1 Safety architecture introduction . 4

# 3.2 Compliant item. 4

3.2.1 Definition of Compliant item 4   
3.2.2 Safety functions performed by Compliant item 4   
3.2.3 Reference safety architectures - 1001. 5   
3.2.4 Reference safety architectures - 1002. 6

# Safety analysis assumptions

3.3.1 Safety requirement assumptions.

Electrical specifications and environment limits 8

# Systematic safety integrity 8

# Hardware and software diagnostics 9

3.6.1 Arm® Cortex®-M7 CPU. 10   
3.6.2 System bus architecture/BusMatrix . 17   
3.6.3 Embedded SRAM. 18   
3.6.4 Embedded flash memory 25   
3.6.5 Power controller (PWR) 31   
3.6.6 Reset and clock controller (RCC) 33   
3.6.7 Clock recovery system (CRS). 35   
3.6.8 Hardware semaphore (HSEM) 35   
3.6.9 General-purpose input/output (GPIO) 36   
3.6.10 Debug system or peripheral control. 39   
3.6.11 System configuration controller (SYSCFG). 40

Direct memory access controller and direct memory access request multiplexer (DMA, MDMA, BDMA, DMAMUX). 41

Chrom-Art Accelerator controller (DMA2D) 43

Extended interrupt and events controller (EXTI) 45

15 Cyclic redundancy-check calculation unit (CRC). 47

6.16 CORDIC co-processor (CORDIC). 47

3.6.17 Filter math accelerator (FMAC). 49

3.6.18 Flexible static memory controller (FSMC) 51

3.6.19 Quad-SPI / Octo-SPI interface (QUADSPI/OCTOSPI) 53   
3.6.20 Delay block (DLYB). .55   
3.6.21 Analog-to-digital converter (ADC) 55   
3.6.22 Digital-to-analog converter (DAC) .58   
3.6.23 Voltage reference buffer (VREFBUF) .59   
3.6.24 Comparator (COMP). .60   
3.6.25 Operational amplifiers (OPAMP) . .62   
3.6.26 Digital filter for sigma delta modulators (DFSDM) . .63   
3.6.27 Digital camera interface (DCMI) .65   
3.6.28 LCD-TFT display controller (LTDC). .66   
3.6.29 JPEG codec (JPEG). .67   
3.6.30 HASH processor (HASH) .68   
3.6.31 On-the-fly decryption engine (OTFDEC) 69   
3.6.32 True random number generator (RNG). .71   
3.6.33 Cryptographic processor (CRYP) .72   
3.6.34 Advanced-control/General-purpose/High resolution and low-power timers 74   
3.6.35 Basic timers 78   
3.6.36 Independent and system window watchdogs (IWDG and WWDG) .79   
3.6.37 Real-time clock module (RTC) 80   
3.6.38 Tamper and backup registers (TAMP) .82   
3.6.39 Inter-integrated circuit (I2C). 82   
3.6.40 Universal synchronous/asynchronous receiver/transmitter and low power universal   
asynchronous receiver/transmitter (USART, UART, LPUART). 85   
3.6.41 Serial peripheral interface (SPI) 88   
3.6.42 Serial audio interface (SAI). .90   
3.6.43 SPDIF receiver interface (SPDIFRX) .92   
3.6.44 Single Wire Protocol Master Interface (SWPMI) . 93   
3.6.45 Management data input/output (MDIOS). .95   
3.6.46 Secure digital input/output MultiMediaCard interface (SDMMC) .97   
3.6.47 Controller area network (FDCAN) .98   
3.6.48 USB on-the-go high-speed (OTG_HS) 101   
3.6.49 Ethernet (ETH): media access control (MAC) with DMA controller 103   
3.6.50 HDMI-CEC (CEC). 104   
3.6.51 Disable and periodic cross-check of unintentional activation of unused peripherals . . . . 106   
3.6.52 System .107   
3.7 Conditions of use. .108   
Safety results. 116

4.1 Random hardware failure safety results. 116

4.1.1 Safety analysis result customization 116   
4.1.2 General requirements for freedom from interferences (FFI) 117   
4.1.3 Notes on multiple-fault scenario 118

4.2 Analysis of dependent failures. 118

4.2.1 Power supply 118   
4.2.2 Clock.. 118   
4.2.3 DMA 119   
4.2.4 Internal temperature 119

# 5 List of evidences 120

Appendix A X-CUBE-STL self-test software library . 121

Revision history 123

Glossary 125

# List of tables

Table 1. Document sections versus IEC 61508-2 Annex D safety requirements 2   
Table 2. SS1 and SS2 safe state details 8   
Table 3. CPU_SM_0. 10   
Table 4. CPU_SM_1. 11   
Table 5. CPU_SM_2. 12   
Table 6. CPU_SM_3. 12   
Table 7. CPPU_SM_4. 13   
Table 8. CPU_SM_5. 14   
Table 9. CPU_SM_6. 14   
Table 10. CPU_SM_7. 15   
Table 11. CPU_SM_9. 15   
Table 12. CPU_SM_10. 16   
Table 13. MPU_SM_0 16   
Table 14. MPU_SM_1 17   
Table 15. BUS_SM_0. 17   
Table 16. BUS_SM_1. 18   
Table 17. RAM_SM_0 18   
Table 18. RAM_SM_2 19   
Table 19. RAM_SM_3 20   
Table 20. RAM_SM_4 21   
Table 21. RAM_SM_5 21   
Table 22. RAM_SM_6 22   
Table 23. RAM_SM_7 23   
Table 24. RAM_SM_8 24   
Table 25. FLASH_SM_0. 25   
Table 26. FLASH_SM_1 26   
Table 27. FLASH_SM_2. 26   
Table 28. FLASH_SM_3. 27   
Table 29. FLASH_SM_4. 27   
Table 30. FLASH_SM_6. 28   
Table 31. FLASH_SM_7. 29   
Table 32. FLASH_SM_8. 30   
Table 33. FLASH_SM_9 30   
Table 34. VSUP_SM_0. 31   
Table 35. VSUP_SM_1. 31   
Table 36. VSUP_SM_2. 32   
Table 37. VSUP_SM_3. 32   
Table 38. VSUP_SM_5. 33   
Table 39. CLK_SM_0. 33   
Table 40. CLK_SM_1 34   
Table 41. CLK_SM_2. 34   
Table 42. CLK_SM_3. 35   
Table 43. HSEM_SM_0 35   
Table 44. HSEM_SM_1 36   
Table 45. GPIO_SM_0 36   
Table 46. GPIO_SM_1 37   
Table 47. GPIO_SM_2 38   
Table 48. GPIO_SM_3 38   
Table 49. DBG_SM_0. 39   
Table 50. LOCK_SM_0. 39   
Table 51. SYSCFG_SM_0 40   
Table 52. DIAG_SM_0 40   
Table 53. DMA_SM_0 41   
Table 54. DMA_SM_1 41   
Table 55. DMA_SM_2 42   
Table 56. DMA_SM_3 42   
Table 57. DMA_SM_4 43   
Table 58. DMA2D_SM_0 43   
Table 59. DMA2D_SM_1 44   
Table 60. DMA2D_SM_2 44   
Table 61. NVIC_SM_0 45   
Table 62. NVIC_SM_1 46   
Table 63. CRC_SM_0. 47   
Table 64. CORD_SM_0 47   
Table 65. CORD_SM_1 47   
Table 66. CORD_SM_2 48   
Table 67. CORD_SM_3 48   
Table 68. FMAC_SM_0 49   
Table 69. FMAC_SM_1 50   
Table 70. FMAC_SM_2 50   
Table 71. FMAC_SM_3 51   
Table 72. FSMC_SM_0 51   
Table 73. FSMC_SM_1 52   
Table 74. FSMC_SM_2 52   
Table 75. FSMC_SM_3 53   
Table 76. QSPI_SM_0 53   
Table 77. QSPI_SM_1 54   
Table 78. QSPI_SM_2 54   
Table 79. DLB_SM_0. 55   
Table 80. ADC_SM_0. 55   
Table 81. ADC_SM_1. 56   
Table 82. ADC_SM_2. 56   
Table 83. ADC_SM_3. 57   
Table 84. ADC_SM_4. 57   
Table 85. DAC_SM_0. 58   
Table 86. DAC_SM_1. 58   
Table 87. VREF_SM_0. 59   
Table 88. VREF_SM_1. 59   
Table 89. COMP_SM_0 60   
Table 90. COMP_SM_1 60   
Table 91. COMP_SM_2 61   
Table 92. COMP_SM_3 61   
Table 93. COMP_SM_4 62   
Table 94. AMP_SM_0. 62   
Table 95. DFS_SM_0. 63   
Table 96. DFS_SM_1. 63   
Table 97. DFS_SM_2. 64   
Table 98. DFS_SM_3. 64   
Table 99. DCMI_SM_0. 65   
Table 100. DCMI_ SM_1 65   
Table 101. LCD_SM_0. 66   
Table 102. LCD_SM_1 66   
Table 103. JPEG_SM_0. 67   
Table 104. JPEG_SM_1. 67   
Table 105. JPEG_SM_2. 68   
Table 106. HASH_SM_0. 68   
Table 107. HASH_SM_1. 69   
Table 108. OTFDEC_SM_0 69   
Table 109. OTFDEC_SM_1 70   
Table 110. OTFDEC_SM_2 70   
Table 111. OTFDEC_SM_3 71   
Table 112. RNG_SM_0 71   
Table 113. RNG_SM_1 72   
Table 114. CRYP_SM_0. 72   
Table 115. CRYP_SM_1. 73   
Table 116. CRYP_SM_2. 73   
Table 117. ATIM_SM_0 74   
Table 118. ATIM_SM_1 75   
Table 119. ATIM_SM_2 76   
Table 120. ATIM_SM_3 77   
Table 121. ATIM_SM_4 77   
Table 122. GTIM_SM_0. 78   
Table 123. GTIM_SM_1 . 78   
Table 124. WDG_SM_0 79   
Table 125. WDG_SM_1 79   
Table 126. RTC_SM_0. 80   
Table 127. RTC_SM_1 80   
Table 128. RTC_SM_2. 81   
Table 129. RTC_SM_3. . 81   
Table 130. TAMP_SM_0. 82   
Table 131. IIC_SM_0. 82   
Table 132. IIC_SM_1 83   
Table 133. IIC_SM_2. 83   
Table 134. IIC_SM_3 . 84   
Table 135. IIC_SM_4 . 84   
Table 136. UART_SM_0. 85   
Table 137. UART_SM_1. 85   
Table 138. UART_SM_2. 86   
Table 139. UART_SM_3. 87   
Table 140. SPI_SM_0 88   
Table 141. SPI_SM_1 88   
Table 142. SPI_SM_2 89   
Table 143. SPI_SM_3 89   
Table 144. SPI_SM_4 90   
Table 145. SAI_SM_0 90   
Table 146. SAI_SM_1 91   
Table 147. SAI_SM_2 91   
Table 148. SPDF_SM_0. 92   
Table 149. SPDF_SM_1. 92   
Table 150. SPDF_SM_2. 93   
Table 151. SWPMI_SM_0. 93   
Table 152. SWPMI_SM_1 94   
Table 153. SWPMI_SM_2. 94   
Table 154. SWPMI_SM_3. 95   
Table 155. MDIO_SM_O. 95   
Table 156. MDIO_SM_1. 96   
Table 157. MDIO_SM_2. 96   
Table 158. SDIO_SM_0 97   
Table 159. SDIO_SM_1 97   
Table 160. SDIO_SM_2 98   
Table 161. CAN_SM_O. 98   
Table 162. CAN_SM_1. 99   
Table 163. CAN_SM_2. 100   
Table 164. USB_SM_0. 101   
Table 165. USB_SM_1. 101   
Table 166. USB_SM_2. 102   
Table 167. USB_SM_3. 102   
Table 168. ETH_SM_0. 103   
Table 169. ETH_SM_1. 103   
Table 170. ETH_SM_2. 104   
Table 171. HDMI_SM_0 104   
Table 172. HDMI_SM_1 105   
Table 173. HDMI_SM_2 105   
Table 174. FFI_SM_0. 106   
Table 175. FFI_SM_1. 106   
Table 176. DUAL_SM_0. 107   
Table 177. List of safety recommendations 108   
Table 178. Overall achievable safety integrity levels. .116   
Table 179. List of general requirements for FFI .117   
Table 180. Document revision history . 123

# List of figures

Figure 1. STMicroelectronics product development process. 3   
Figure 2. STM32 as Compliant item 4   
Figure 3. 1001 reference architecture 5   
Figure 4. 1002 reference architecture 6   
Figure 5. Allocation and target for STM32 PST. 7   
Figure 6. STL architecture 121

# IMPORTANT NOTICE  READ CAREFULLY

ST products and/or to this document any time without notice.

T

conditions

purchasers' products.

granted by ST herein.

are the property of their respective owners.